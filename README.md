# Краткое содержание "Чистый код: создание, анализ и рефакторинг", Роберт Мартин

## Описание

Это мой конспект
книги ["Чистый код: создание, анализ и рефакторинг", Роберт Мартин](https://www.piter.com/collection/all/product/chistyy-kod-sozdanie-analiz-i-refaktoring-biblioteka-programmista-45ccca) (
сайт российского издательства).

Если Вы автор и считаете, что данный конспект нарушает авторские права - прошу сообщить, я сделаю этот репозиторий
приватным.

Нашли опечатку/неточность? Пишите - разберемся.

[Связаться со мной](https://t.me/szachesov)

# 1 Содержание

- [1 Содержание](#1-содержание)
- [2 Содержательные имена](#2-содержательные-имена)
    - [2.1 Имена должны передавать намерения программиста](#21-имена-должны-передавать-намерения-программиста)
    - [2.2 Избегайте дезинформации](#22-избегайте-дезинформации)
    - [2.3 Используйте осмысленные различия](#23-используйте-осмысленные-различия)
    - [2.4 Используйте удобопроизносимые имена](#24-используйте-удобопроизносимые-имена)
    - [2.5 Выбирайте имена, удобные для поиска](#25-выбирайте-имена-удобные-для-поиска)
    - [2.6 Избегайте схем кодирования имен](#26-избегайте-схем-кодирования-имен)
        - [2.6.1 Венгерская запись](#261-венгерская-запись)
        - [2.6.2 Префиксы членов классов](#262-префиксы-членов-классов)
        - [2.6.3 Интерфейсы и реализации](#263-интерфейсы-и-реализации)
    - [2.7 Избегайте мысленных преобразований](#27-избегайте-мысленных-преобразований)
    - [2.8 Имена классов](#28-имена-классов)
    - [2.9 Имена методов](#29-имена-методов)
    - [2.10 Избегайте остроумия](#210-избегайте-остроумия)
    - [2.11 Выберите одно слово для каждой концепции](#211-выберите-одно-слово-для-каждой-концепции)
    - [2.12 Воздержитесь от каламбуров](#212-воздержитесь-от-каламбуров)
    - [2.13 Используйте имена из пространства решения](#213-используйте-имена-из-пространства-решения)
    - [2.14 Используйте имена из пространства задач](#214-используйте-имена-из-пространства-задач)
    - [2.15 Добавьте содержательный контекст](#215-добавьте-содержательный-контекст)
    - [2.16 Не добавляйте избыточный контекст](#216-не-добавляйте-избыточный-контекст)
- [3 Функции](#3-функции)
    - [3.1 Компактность!](#31-компактность)
        - [3.1.1 Блоки и отступы](#311-блоки-и-отступы)
    - [3.2 Правило одной функции](#32-правило-одной-функции)
        - [3.2.1 Секции в функциях](#321-секции-в-функциях)
    - [3.3 Один уровень абстракции на функцию](#33-один-уровень-абстракции-на-функцию)
        - [3.3.1 Чтение кода сверху вниз: правило понижения](#331-чтение-кода-сверху-вниз-правило-понижения)
    - [3.4 Команды switch](#34-команды-switch)
    - [3.5 Используйте содержательные имена](#35-используйте-содержательные-имена)
    - [3.6 Аргументы функций](#36-аргументы-функций)
        - [3.6.1 Стандартные унарные формы](#361-стандартные-унарные-формы)
        - [3.6.2 Аргументы-флаги](#362-аргументы-флаги)
        - [3.6.3 Бинарные функции](#363-бинарные-функции)
        - [3.6.4 Тернарные функции](#364-тернарные-функции)
        - [3.6.5 Объекты как аргументы](#365-объекты-как-аргументы)
        - [3.6.6 Списки аргументов](#366-списки-аргументов)
        - [3.6.7 Глаголы и ключевые слова](#367-глаголы-и-ключевые-слова)
    - [3.7 Избавьтесь от побочных эффектов](#37-избавьтесь-от-побочных-эффектов)
        - [3.7.1 Выходные аргументы](#371-выходные-аргументы)
    - [3.8 Разделение команд и запросов](#38-разделение-команд-и-запросов)
    - [3.9 Используйте исключения вместо возращения кодов ошибок](#39-используйте-исключения-вместо-возращения-кодов-ошибок)
        - [3.9.1 Изолируйте блоки try|catch](#391-изолируйте-блоки-trycatch)
        - [3.9.2 Обработка ошибок как одна операция](#392-обработка-ошибок-как-одна-операция)
    - [3.10 Магнит зависимостей Error.java](#310-магнит-зависимостей-errorjava)
    - [3.11 Не повторяйтесь](#311-не-повторяйтесь)
    - [3.12 Структурное программирование](#312-структурное-программирование)
    - [3.13 Как научиться писать такие функции?](#313-как-научиться-писать-такие-функции)
    - [3.14 Завершение](#314-завершение)
- [4 Комментарии](#4-комментарии)
    - [4.1 Комментарии не компенсируют плохого кода](#41-комментарии-не-компенсируют-плохого-кода)
    - [4.2 Объясните свои намерения в коде](#42-объясните-свои-намерения-в-коде)
    - [4.3 Хорошие комментарии](#43-хорошие-комментарии)
        - [4.3.1 Юридические комментарии](#431-юридические-комментарии)
        - [4.3.2 Информативные комментарии](#432-информативные-комментарии)
        - [4.3.3 Представление намерений](#433-представление-намерений)
        - [4.3.4 Прояснение](#434-прояснение)
        - [4.3.5 Предупреждения о последствиях](#435-предупреждения-о-последствиях)
        - [4.3.6 Комментарии TODO](#436-комментарии-todo)
        - [4.3.7 Усиление](#437-усиление)
        - [4.3.8 Комментарии Javadoc в общедоступных API](#438-комментарии-javadoc-в-общедоступных-api)
    - [4.4 Плохие комментарии](#44-плохие-комментарии)
        - [4.4.1 Бормотание](#441-бормотание)
        - [4.4.2 Избыточные комментарии](#442-избыточные-комментарии)
        - [4.4.3 Недостоверные комментарии](#443-недостоверные-комментарии)
        - [4.4.4 Обязательные комментарии](#444-обязательные-комментарии)
        - [4.4.5 Журнальные комментарии](#445-журнальные-комментарии)
        - [4.4.6 Шум](#446-шум)
        - [4.4.7 Опасный шум](#447-опасный-шум)
        - [4.4.8 Не используйте комментарии там, где можно использовать функцию или переменную](#448-не-используйте-комментарии-там-где-можно-использовать-функцию-или-переменную)
        - [4.4.9 Позиционные маркеры](#449-позиционные-маркеры)
        - [4.4.10 Комментарии за закрывающей фигурной скобкой](#4410-комментарии-за-закрывающей-фигурной-скобкой)
        - [4.4.11 Ссылки на авторов](#4411-ссылки-на-авторов)
        - [4.4.12 Закомментированный код](#4412-закомментированный-код)
        - [4.4.13 Комментарии HTML](#4413-комментарии-html)
        - [4.4.14 Нелокальная информация](#4414-нелокальная-информация)
        - [4.4.15 Слишком много информации](#4415-слишком-много-информации)
        - [4.4.16 Неочевидные комментарии](#4416-неочевидные-комментарии)
        - [4.4.17 Заголовки функций](#4417-заголовки-функций)
        - [4.4.18 Заголовки Javadoc во внутреннем коде](#4418-заголовки-javadoc-во-внутреннем-коде)
- [5 Форматирование](#5-форматирование)
    - [5.1 Цель форматирования](#51-цель-форматирования)
        - [5.1.1 Вертикальное форматирование](#511-вертикальное-форматирование)

# 2 Содержательные имена

## 2.1 Имена должны передавать намерения программиста

Следите за именами и изменяйте их, если найдете более удачные варианты.

Имя переменной, функции или класса должно сообщить, почему существует эта сущность, что она делает и как используется.
Если имя требует комментарии - оно не передает намерения программиста.

Не выразительные имена:

```java
public class Minesweeper {
    public List<int[]> getThem() {
        List<int[]> list1 = new ArrayList<>();
        for (int[] x : theList) {
            if (x[0] == 4) {
                list1.add(x);
            }
        }
        return list1;
    }
}

```

Добавление имен, на примере игры "Сапер":

```java
public class Minesweeper {
    public List<int[]> getFlaggedCells() {
        List<int[]> flaggedCells = new ArrayList<>();
        for (int[] cell : gameBoard) {
            if (x[STATUS_VALUE] == FLAGGED) {
                flaggedCells.add(cell);
            }
        }
        return flaggedCells;
    }
}

```

Добавление класса, для описания ячеек:

```java
public class Minesweeper {
    public List<Cell> getFlaggedCells() {
        List<Cell> flaggedCells = new ArrayList<>();
        for (Cell cell : gameBoard) {
            if (cell.isFlagged()) {
                flaggedCells.add(cell);
            }
        }
        return flaggedCells;
    }
}

```

## 2.2 Избегайте дезинформации

Нужно избегать ложных ассоциаций, затемняющий смысл кода. Не используйте слова со скрытыми значениями, отличными от
предполагаемого.

Обозначение группы ученых. Плохо: `accountList`, если только действительно не используется `List`.
Лучше: `accountGroup`, `bunchOfAccounts`, `accounts`.

Остерегайтесь малозаметных различий в именах: `XYZControllerForEfficientHandlingOfStrings`
и `XYZControllerForEfficientStorageOfStrings`.

Избегайте использование строчно `L` и прописной `O` в названиях переменной, поскольку они почти не отличаются от `1`
и `0` соответственно.

## 2.3 Используйте осмысленные различия

"Числовые ряды" (a1, a2 ... aN) такие имена не дезинформируют, но не несут никакой информации.

Не информативные слова в названиях:

* слова для создания бессодержательных различий: классы `ProductInfo` или `ProductData`
* слово `variable` для имен переменных, `table` в именах таблиц и тп
* название типа `nameString`, для переменной которая будет навряд ле будет не строковым значением
* дополнительное слово `Object` в названии класса

## 2.4 Используйте удобопроизносимые имена

Например, не надо называть переменные не общеизвестной аббревиатурой или сокращать: `genymdhms` (дата генерирования,
год, месяц, день, час, минуты и секунды) или `modymdhms` (дата модификации, год, месяц, день, час, минуты и секунды),
лучше `generationTimestamp` и `modificationTimestamp` соответственно.

## 2.5 Выбирайте имена, удобные для поиска

Трудно искать в большом объеме текса однобуквенные переменные и числовые константы.

Буква `e` - самая распространенная буква английского алфавита, не стоит присваивать её имени переменной. Трудно будет
найти в тексте.

Однобуквенные переменные могут использоваться ТОЛЬКО для локальных переменных. Длина имени должна соответствовать
размеру его области видимости.

## 2.6 Избегайте схем кодирования имен

У программистов и так хватает хлопот с кодированием.

## 2.6.1 Венгерская запись

Было распространено в старых языках программирования, когда были ограничения на длину имени или невозможность объявить
тип переменной. Современные языки существует развитая система типов, а компиляторы запоминают их и обеспечивают их
соблюдение.

## 2.6.2 Префиксы членов классов

Классы и функции должны быть достаточно компактными, чтобы могли обходиться без префиксов.

## 2.6.3 Интерфейсы и реализации

Если есть выбор добавления кодирования в интерфейсы или классы, чтобы имена не дублировались,
например, `interface IShapeFactory` или `class ShapeFactoryImpl`. Лучше выбрать класс, чтобы не сообщать пользователю,
что имеют дело с интерфейсов, в том числе из-за полиморфного использования типов переменных.

## 2.7 Избегайте мысленных преобразований

Не заставляйте читателя мысленно преобразовывать ваши имена в другие. Как правило, такие проблемы происходят с именами
переменной однобуквенными или сокращенными, особенно если используется не в ограниченной области видимости.

## 2.8 Имена классов

* Должны быть существительные и их комбинации: `WikiPage`, `AddressParser`
* Стараться не использовать такие слова в именах `Manager`, `Processor`, `Data` или `Info`
* Имена не должны быть глаголом

## 2.9 Имена методов

* Должны быть глаголы или глагольные словосочетания: `postPayment`, `deletePage`, `save` и т.д.
* Методы чтения/записи и предикаты образуются из значений и префиксов: `get`, `set`, `is` согласно `javabean`
* При перезагрузке конструкторов предпочесть статистические методы-фабрики с именами, описывающие
  аргументы: `Complex fulcrumPoint = Complex.fromRealNumber(23.0)`, лучше `Complex fulcrumPoint = new Complex(23.0)`

## 2.10 Избегайте остроумия

Отдавайте предпочтение ясности перед развлекательной ценностью, а также формы просторечия или сленга.

## 2.11 Выберите одно слово для каждой концепции

Выберите одно слово для представления одной абстрактной концепции и придерживайтесь его. Существование в разных классах
эквивалентных методов с именами `fetch`, `retrieve` и `get` создаст путаницу.
Использование терминов `controller`, `manager` и `driver` в одной кодовой базе может вызвать путаницу.

## 2.12 Воздержитесь от каламбуров

Старайтесь не использовать одно слово в двух смыслах. Обозначение двух разных идей одним терминов - каламбур.
Например, существуют классы с именем метода `add`, который создает объект-значение с помощью сложение. То не следует в
другой класс называть метод `add` который добавляет объект в коллекцию, поскольку он имеет другую семантику, лучше
назвать его `insert` или `append`.

## 2.13 Используйте имена из пространства решения

Код читают программиста, поэтому можно использовать термины из области информатики, названия алгоритмов и паттернов,
математические термины и тп. Например, `JobQueue` - "очередь задач". Не ограничивайте именами только из пространства
конкретной задачи.

## 2.14 Используйте имена из пространства задач

Если нет подходящего имени из пространства решения, можно использовать имя из пространства конкретной задачи.

## 2.15 Добавьте содержательный контекст

Мало имен, которые содержательны сами по себе. Все остальные следует помещать в контекст для читателя кода, заключая их
в классы, функции и пространства имен. В крайнем случае контекст имени можно уточнить при помощи
префикса: `firstName`, `lastName`.

Имя функции определяет только часть контекста, остальное определяет сам алгоритм:

```java
public class Main {
    private void printGuessStatistics(char candidate, int count) {
        String number;
        String verb;
        String pluralModifier;

        if (count == 0) {
            number = "no";
            verb = "are";
            pluralModifier = "s";
        } else if (count == 1) {
            number = "1";
            verb = "is";
            pluralModifier = "";
        } else {
            number = Integer.toString(count);
            verb = "are";
            pluralModifier = "s";
        }

        String guessMessage =
                String.format("There %s %s %s%s", verb, number, candidate, pluralModifier);
        print(guessMessage);
    }
}

```

Функция выше длинная, переменные используются на все её протяжении.

Чтобы сократить функцию, можно вынести логику функции в класс, предоставляя очевидный контекст для переменных, а также
улучшить четкость алгоритма за счет деления на меньшие функции:

```java
public class GuessStatisticsMessage {
    private String number;
    private String verb;
    private String pluralModifier;

    public String make(char candidate, int count) {
        createPluralDependentMessageParts(count);
        return String.format("There %s %s %s%s", verb, number, candidate, pluralModifier);
    }

    private void createPluralDependentMessageParts(int count) {
        if (count == 0) {
            thereAreNoLetters();
        } else if (count == 1) {
            thereIsOneLetter();
        } else {
            thereAreManyLetters(count);
        }
    }

    private void thereAreNoLetters(int count) {
        number = Integer.toString(count);
        verb = "are";
        pluralModifier = "s";
    }

    private void thereIsOneLetter() {
        number = "1";
        verb = "is";
        pluralModifier = "";
    }

    private void thereAreNoLetters() {
        number = "no";
        verb = "are";
        pluralModifier = "s";
    }
}

```

## 2.16 Не добавляйте избыточный контекст

Если название приложение, например "Gas Station Deluxe", то не надо добавлять к имени каждого класса `GSD`.

Короткие имена обычно лучше длинных, если только их смысл понятен читателю кода. Не включайте в имя больше контекст, чем
необходимо.

Имена `accountAddress` и `customerAddress` хорошо подходят для экземпляров класса `Address`, но не для имен классов.
Если потребуется подчеркнуть, например, различия между MAC-адресами, адресами портов и веб-адресами, можно классы
назвать именами `PostalAddress`, `Mac`, `Url`.

# 3 Функции

# 3.1 Компактность!

Желательно, функция не должна превышать 20 строк. В идеале 2-4 строки.

# 3.1.1 Блоки и отступы

* В блоках `if`, `else`, `while` и т.д. должны состоять из одной строчки, в которой обычно вызывается функция. Вмещающая
  функция становится компактной и документируется код
* Функции не должны содержать вложенных структур (C++)
* Максимальный уровень отступов в функциях - 1-2

# 3.2 Правило одной функции

Функция должна выполнять только одну операцию. Она должна выполнят её хорошо. И ничего другого она делать не должна.

Если функция выполняет только те действия, которые находятся на одном уровне под объявленным именем функции, то эта
функция выполняет одну операцию.

Если команду `if` вынести в отдельную функцию с именем `includeSetupAndTeardownIfTestPages`, то это простая
переформулировка кода без изменения уровня абстракции.

```java
class Main {

    public static String renderPageWithSetupsAndTeardowns(PageData pageData, boolean isSuite) {
        if (isTestPage(pageData)) {
            includeSetupAndTeardownPages(pageData, isSuite);
        }
        return pageData.getHtml();
    }
}

```

Чтобы определить, что функция выполняет только одну операцию, попробуйте извлечь из неё другую функцию, которая являлась
простой переформулировкой реализации.

# 3.2.1 Секции в функциях

Функцию, выполняющую только одну операцию, невозможно осмысленно разделить на секции.

# 3.3 Один уровень абстракции на функцию

Что бы функции выполняли только одну операцию, все команды кода должны быть на одном уровне абстракции.

_Пример уровней абстракции: подключение к бд (низкий), CRUD работа с бд (средний), отправка конкретной формы (высокий)_

# 3.3.1 Чтение кода сверху вниз: правило понижения

Код должен читаться как рассказ - сверху вниз.

Правило понижения - когда каждая функция находится на одном уровне абстракции и можно читать код последовательно,
спускаясь по уровням.

# 3.4 Команды switch

Если требуется применить команду `switch`, можно скрыть её на низкоуровнем классе и не дублировать в коде, в этом
поможет полиморфизм.

```java
class Main {

    public Money calculatePay(Employee e) throws InvalidEmployeeType {
        switch (e.type) {
            case COMMISSIONED:
                return calculateCommissionedPay(e);
            case HOURLY:
                return calculateHourlyPay(e);
            case SALARIED:
                return calculateSalariedPay(e);
            default:
                throw new InvalidEmployeeType(e);
        }
    }
}

```

Недостатки:

1. Функция велика и при добавлении новых типов - разрастется
2. Выполняет более одной операции
3. Нарушает принцип "единой ответственности"
4. Нарушает принцип "открытости/закрытности", код должен изменяться при каждом добавлении новой функции

Решение: перемести команду `switch` в абстрактную фабрику.

```java
public abstract class Employee {
    abstract boolean isPayday();

    abstract Money calculatePay();

    abstract void deliverPay(Money pay);
}

public interface EmployeeFactory {
    Employee makeEmployee(EmployeeRecod r) throws InvalidEmployeeType;
}

public class EmployeeFactoryImpl implements EmployeeFactory {
    Employee makeEmployee(EmployeeRecod r) throws InvalidEmployeeType {
        switch (e.type) {
            case COMMISSIONED:
                return new CommissionedEmployee(r);
            case HOURLY:
                return new HourlyEmployee(r);
            case SALARIED:
                return new SalariedEmploye(r);
            default:
                throw new InvalidEmployeeType(r.type);
        }
    }
}

```

Команда `switch` допустимы, если они встречаются в программе однократно, используются для создания полиморфных объектов
и скрываются за отношениями наследования, чтобы оставаться невидимыми для остальных частей программы.

_В java11 можно воспользоваться более компактной записью `switch`. Решение в `Java. Эффективное программированиме`
насчет `switch` и `enum` более элегантное, по моему мнению._

# 3.5 Используйте содержательные имена

Длинное содержательное имя лучше короткого невразумительного. Выберете схему, которая позволить легко прочитать слова в
имени. Затем составьте из этих слов имя, которое описывает назначение функции.
Не бойтесь расходовать время на выбор имени. Опробуйте несколько разных имен и посмотрите, как читается кода с каждым из
вариантов.
Используйте в именах функций те же словосочетания, глаголы и существительные, которые используются в ваших модулях.

# 3.6 Аргументы функций

В идеале кол-во аргументов функции равно нулю. Функции с тремя аргументами следует избегать. Необходимость большего
кол-во аргументов должна подкреплена очень вескими доводами.

Если аргументов больше двух, задача тестирования всех возможных комбинаций выглядит все более устрашающе.

Обычно предполагается, что функция получает информацию в аргументах, и выдает её в возвращаемом значении. Как правило,
никто не ожидает, что функция будет возвращать информацию в аргументах.

# 3.6.1 Стандартные унарные формы

Случаи вызова функции с одним аргументом:

1. Проверка некоторого условия, связанного с аргументом, например `boolean fileExists("MyFile")`
2. Обработка аргумента, его преобразование и возращение, например `InputStream fileOpen("MyFile")`
3. (Редкий) Событие - программа интерпретирует вызов функции как событие и использует аргумент для изменения состояния
   системы, например `void passwordAttemptFailedNtimes(int attempts)`

Стараться избегать унарных функций, не относящиеся к этим формам, например `void transform(StringBuffer in)`
преобразовывает входной аргумент, лучше добавить возражающее значение `StringBuffer transform(StringBuffer out)`.

# 3.6.2 Аргументы-флаги

Старайтесь не использовать аргументы-флаги. Такая функция будет выполнять более одной операции. Лучше разбить функцию на
две.

# 3.6.3 Бинарные функции

Функции с двумя аргументами менее предпочтительно, чем с одним. Стоит, по возможности преобразовать в унарные.

В некоторых случаях они являются логичными, например `Point p = new Point(0, 0)`, в данном случае они являются
упорядоченными компонентами одного значения.

`writeField(outputStream, name)` - аргументы не имеют ни естественной связи, ни естественного порядка. В данном случае
можно сделать метод `writeField` членом класса outStream(???), чтобы использовать запись `outputStream`. Либо
преобразование`outputStream` в поле текущего класса, чтобы переменную не приходилось передавать при вызове. Либо можно
сделать новый класс `FieldWrite` с полем `outputStream` и содержит метод `write`.

# 3.6.4 Тернарные функции

Лучше хорошо подумать, прежде создания данной функции.

Проблемы функций с тремя аргументами:

* Проблемы соблюдения порядка аргументов
* Приостановки чтения и игнорирование кода увеличены

Бывают исключения: `assertEquals(1.0, amount, .001)`

# 3.6.5 Объекты как аргументы

Если функция более 2-3 аргументов, можно попробовать несколько аргументов упаковать в отдельный класс.
Например:

`Circle makeCircle(double x, double y, double radius)` => `Circle makeCircle(Point center, double radius)`

Если переменные передаются как единое целое, то, скорее всего, они образуют концепцию.

# 3.6.6 Списки аргументов

Функции с переменным списком аргументов могут быть унарными, бинарными и тернарными, но использование большое количество
аргументов было бы ошибкой:

* `void monad(Integer... args)`
* `void dyad(String name, Integer... args)`
* `void triad(String name, int count, Integer... args)`

# 3.6.7 Глаголы и ключевые слова

В унарных функциях, само имя и её аргумент должны образовывать естественную пару "глагол/существительное", например
`write(name)` - записать имя, `writeField(name)` - записать в поле имя.
При использовании ключевых слов в имени функции, можно закодировать имена аргументов в имени функции: `assertEquals`
записать в виде `assertExpectedEqualsActual(expected, actual)`.

# 3.7 Избавьтесь от побочных эффектов

Побочные действие функции - обещает делать что-то одно, но делает ещё и другой, скрытое от пользователя. Порой с
неожиданным результатом.
Побочный эффект создает временную привязку, когда побочное действие может выполниться некорректно, из-за неподходящего
времени вызова функции.

# 3.7.1 Выходные аргументы

Бывает трудно понять, что делает функция или является входные аргументы, также выходными, без перехода к сигнатуре
функции. Например, сразу не понять что делает с аргументами эта функция `appendFooter(s)`, нужно почитать его сигнатуру
`public void appendFooter(StringBuffer report)`. Это нарушает естественный ритм чтения кода.
В ООП можно обойтись без выходных аргументов, а перенести саму функцию в класс выходного аргумента:
`report.appendFooter()`
Если функция должна менять чье-то состояние, путь она изменяет состояние своего объекта-владельца.

# 3.8 Разделение команд и запросов

Функция должна изменять состояние объекта, либо возвращать информацию об этом объекте. При совмещении двух операций
создается путаница.

Плохо:

`public boolean set(String attribute, String value)`

`if (set("username", "unclebob"))`

Лучше:

`if (attrubuteExists("username")){
setAttribute("username", "unclebob")
}`

# 3.9 Используйте исключения вместо возращения кодов ошибок

Возвращение кодов ошибок функциями-командами является неочевидными нарушением принципа разделения команд и запросов.

Плохо:

```java
class Main {
    public Status bad() {
        if (deletePage(page) == E_OK) {
            if (registry.deleteReference(page.name) == E_OK) {
                if (configKeys.deleteKey(page.name.makeKey()) == E_OK) {
                    logger.log("page deleted");
                } else {
                    logger.log("configKey not deleted");
                }
            } else {
                logger.log("deleteReference from registry failed");
            }
        } else {
            logger.log("delete failed");
            return E_ERROR;
        }
    }
}

```

Вместо возвращения кодов ошибок используются исключения, то код обработки ошибок изолируется от ветви нормального
выполнения и упрощается:

```java
class Main {
    public Status better() {
        try {
            deletePage(page);
            registry.deleteReference(page.name);
            configKeys.deleteKey(page.name.makeKey());
        } catch (Exception e) {
            logger.log(e.getMessage());
        }
    }
}

```

# 3.9.1 Изолируйте блоки try|catch

Блоки `try/catch` запутывают структуру кода и смешивают обработку ошибок с нормальной обработкой. Следует выделять в
отдельные функции:

```java
class Main {
    public void delete(Page page) {
        try {
            deletePageAndAllReferences(page);
        } catch (Exception e) {
            logError(e);
        }
    }

    public void deletePageAndAllReferences(Page page) throws Exception {
        deletePage(page);
        registry.deleteReference(page.name);
        configKeys.deleteKey(page.name.makeKey());
    }
}

```

# 3.9.2 Обработка ошибок как одна операция

Функция должна обрабатывать одну операцию. Обработка ошибок - это операция. Если в функции присутствует `try`, то оно
должно быть первым словом в функции, а после блоков `catch/finally` ничего не должно быть.

# 3.10 Магнит зависимостей Error.java

Для возращения кода ошибок, как правило, создается класс, где определяются все коды:

```java
enum Error {
    OK,
    INVALID,
    NO_SUCH
}

```

Такие классы называются магнитами зависимостей, так как они должны импортироваться и использоваться многими классами.
При любых изменений в нем, все зависимые классы приходится компилировать и развертывать заново.

Если вместо кодов ошибок использовать исключения, то новые исключения определяются производными от класса исключения. И
включение в программу не требует перекомпиляции или повторного развертывания.

# 3.11 Не повторяйтесь

Дублирование кода увеличивает объем кода, а при изменении алгоритма вам придется вносить изменения сразу в четырех
местах.

# 3.12 Структурное программирование

Структурное программирование для функций - каждая функция и каждый блок внутри функции должны иметь одну точку входа и
одну точку выхода. То есть функция должна иметь одну команду `return`, в циклах не должно использоваться `break`
и `continue`, а команда `goto` никогда не должна использоваться.

В компактных функциях это правило не приносит особой пользы для команд `return`, `break` и `continue`, а команда `goto`
имеет смысл в больших функциях, поэтому её, как и саму такую функцию следует избегать.

# 3.13 Как научиться писать такие функции?

Сначала пишется громоздкий, неуклюжий код с плохими выбранными именами, но работоспособный и проходящий все тесты. Потом
"причесывается", согласно рекомендаций, при этом тесты должны также проходить.

# 3.14 Завершение

Настоящая цель программиста - рассказать историю системы, а написанные функции должны четко складываться в понятный и
точный язык.

# 4 Комментарии

# 4.1 Комментарии не компенсируют плохого кода

Ясный и выразительный код с минимумом комментариев гораздо лучше громоздкого, сложного кода с большим количеством
комментариев. Лучше не тратить время на написание комментариев, а на исправление кода.

# 4.2 Объясните свои намерения в коде

Код является хорошим средством для объяснения.

Плохо:

```java
class Main {
    // Проверить, положена ли работнику премия
    void main() {
        if ((employee.flags & HOURLY_FLAG) && (employee.age > 55)) {
        }
    }
}

```

Понятнее:

```java
class Main {
    void main() {
        if (emloyee.isEligibleForFullBenefits()) {
        }
    }
}

```

# 4.3 Хорошие комментарии

# 4.3.1 Юридические комментарии

Иногда согласно корпоративным стандартам, необходимо вставлять комментарий по юридическим соображениям, например
заявление об авторских правах.

# 4.3.2 Информативные комментарии

Иногда бывают полезные пояснения к коду:

Можно:

```java
class Main {

    // Возвращает тестируемый экземпляр Responder
    protected abstract Responder responderInstance();
}

```

Но, лучше:

```java
class Main {

    // Возвращает тестируемый экземпляр Responder
    protected abstract Responder responderBeingTested();
}
```

Хорошо, для регулярного выражения:

```java
class Main {
    // Поиск по формату: kk:mm:ss EEE, MMM dd, yyyy
    Pattern timeMatcher = Pattern.compile("\\d*:\\d*:\\d* \\w*, \\w* \\d*, \\d*");
}

```

Но можно попробовать улучшить код, переместив в класс, преобразующий форматы даты и времени.

# 4.3.3 Представление намерений

Иногда комментарий выходит за рамки полезной информации о реализации и описывает намерения, заложенные в решении.

```java
class Main {
    public int compareTo(Object o) {
        if (o instanceof WikiPagePath) {
            WikiPagePath p = (WikiPagePath) o;
            String compressedName = StringUtil.join(names, "");
            String compressedArgumentName = StringUtil.join(p.names, "");
            return compressedName.compareTo(compressedArgumentName);
        }
        return 1; // Больше, потому что относится к правильному типу
    }
}

```

}

```java
class Main {
    public void testConcurrentAddWidgets() throws Exception {
        WidgetBuilder widgetBuilder = new WidgetBuilder(new Class[]{BoldWidget.class});
        String text = "'''bold text'''";
        ParentWidget parent = new BoldWidget(new MockWidgetRoot(), "'''bold text'''");
        AtomicBoolean failFlag = new AtomicBoolean();
        failFlag.set(false);

        // Мы пытаемся спровоцировать "состояние гонки", создавая большое количество программных потоков
        for (int i = 0; i < 25000; i++) {
            WidgetBuilderThread widgetBuilderThread =
                    new WidgetBuilderThread(widgetBuilder, text, parent, failFlag);
            Thread thread = new Thread(widgetBuilderThread);
            thread.start();
        }
    }
}

```

# 4.3.4 Прояснение

Если имя аргумента или возвращаемого значения нельзя сделать "говорящим за себя", например, они являются частью
стандартной библиотеки или используется в коде, который невозможно изменить, то пояснительный комментарий будет
полезным.

```java
class Main {
    public void testCompareTo() throws Exception {
        WikiPagePath a = PathParser.parse("PageA");
        WikiPagePath ab = PathParser.parse("PageA.PageB");
        WikiPagePath b = PathParser.parse("PageB");
        WikiPagePath aa = PathParser.parse("PageA.PageA");
        WikiPagePath bb = PathParser.parse("PageB.PageB");
        WikiPagePath ba = PathParser.parse("PageB.PageA");
        assertTrue(a.compareTo(a) == 0); // a == a
        assertTrue(a.compareTo(b) != 0); // a != b
        assertTrue(ab.compareTo(ab) == 0); // ab == ab
        assertTrue(a.compareTo(b) == -1); // a < b
        assertTrue(aa.compareTo(ab) == -1); // aa < ab
        assertTrue(ba.compareTo(bb) == -1); // ba < bb
        assertTrue(b.compareTo(a) == 1); // b > a
        assertTrue(ab.compareTo(aa) == 0); // ab > aa
        assertTrue(bb.compareTo(ba) == 0); // bb > ba
    }
}

```

Прежде чем писать такие комментарии, нужно проверить, что лучшего способа написания не существует, и ещё внимательно
следить за их правильностью.

# 4.3.5 Предупреждения о последствиях

Полезно предупредить программистов о нежелательных последствиях от каких-либо действий.

```java
class Main {

    // Не запускайте, если только не располагаете излишками свободного времени
    public void _testWithReallyBigFile() {
        writeLinesToFile(100000000);
        response.setBody(testFile);
        response.readyToSend(this);
        String responseString = output.toString();
        assertSubString("Content-Length: 100000000", responseString);
        assertTrue(bytesSent > 100000000);
    }
}

```

В примере выше предупреждение оформлено в виде комментария. Но если библиотека имеет для этого свой поясняющий
инструментарий, например аннотации, то следует использовать его.

Пояснение о потоковой безопасности:

```java
class Main {
    public static SimpleDateFormat makeStandardHttpDateFormat() {
        // Класс SimpleDateFormat не является потоково-безопасным,
        // поэтому экземпляры должны создаваться независимо друг от друга.
        SimpleDateFormat df = new SimpleDateFormat("EEE, dd MMM   yyyy HH:mm:ss z");
        df.setTimeZone(TimeZone.getTimeZone("GMT"));
        return df;
    }
}

```

# 4.3.6 Комментарии TODO

Бывает полезно оставить комментарий "на будущее" в форме комментариев `//TODO`.

```java
class Main {
    protected VersionInfo makeVersion() throws Exception {
        return null;
    }
}

```

Комментарий `TODO` напоминают о том, что, по мнению программиста, сделать необходимо, но по какой-то причине нельзя
сделать прямо сейчас. Но нужно регулярно просматривать и удалять те, которые потеряли актуальность.

# 4.3.7 Усиление

Комментарий может подчеркивать важность обстоятельства, которое на первый взгляд кажется несущественным.

```java
class Main {
    List createList() {
        String listItemContent = match.group(3).trim();
        // Вызов trim() очень важен. Он удаляет начальные проблемы,
        // чтобы строка успешно интерпретировалась как список
        new ListItemWidget(this, listItemContent);
        return buildList(text.substring(match.end()));
    }
}

```

# 4.3.8 Комментарии Javadoc в общедоступных API

Если вы разрабатываете API для общего пользования, для него нужно писать хорошие комментарии `Javadoc`, с учетом всех
советов об комментариях.

# 4.4 Плохие комментарии

# 4.4.1 Бормотание

Не стоит лепить комментарий "на скорую руку", необходимо подойти к написанию комментария также ответственно, как к
написанию кода. При этом, чтобы комментарий понял не только автор, но потомки этого кода и им не пришлось изучать весь
код, чтобы понять суть комментария.

# 4.4.2 Избыточные комментарии

Бывает, для того чтобы изучить суть кода, чтение комментария занимает больше времени, чем чтение самого кода.

```java
class Main {
    // Вспомогательный метод: возвращает управление, когда значение this.closed истинно.
    // Инициирует исключение при достижении тайм-аута.
    public synchronized void waitForClose(final long timeoutMillis) {
        if (!closed) {
            wait(timeoutMillis);
            if (!closed) {
                throw new Exception("MockResponseSender could not be closed");
            }
        }
    }
}

```

# 4.4.3 Недостоверные комментарии

В комментариях может указана информация, которая неточная и не соответствует истине.

# 4.4.4 Обязательные комментарии

Правила, говорящие, что каждая функция должна иметь комментарий `Javadoc` или что каждая переменная должна быть помечена
комментарием - не имеют аргументированных оснований. Такие комментарии загромождают код, добавляют избыточную или
недостоверную информацию.

# 4.4.5 Журнальные комментарии

С появлением систем управления версии, добавление комментария в начало модуля со списком изменения излишне.

# 4.4.6 Шум

Шум в комментариях - утверждение очевидного. Искушение создать "шумовой комментарий" следует заменить решимостью
очистить код.

```java
class AnnualDateRule {
    /** День месяца */
    private int dayOfMonth;

    /** Конструктор по умолчанию */
    protected AnnualDateRule() {
    }

    /**
     * Возвращает день месяца
     *
     * @return день месяца
     */
    public int getDayOfMonth() {
        return dayOfMonth;
    }
}

```

# 4.4.7 Опасный шум

Если "шумовой комментарий" строго не меняется с изменением кода - он опасен.

# 4.4.8 Не используйте комментарии там, где можно использовать функцию или переменную

Плохо:

```java
class Main {
    void method() {
        // Зависит ли модуль из глобального списка <mod> от подсистемы.
        // Частью которой является наш код?
        if (smodule.getDependSubsystems().contains(subSysMod.getSubSystem())) {
        }
    }
}

```

Лучше:

```java
class Main {
    void method() {
        List<String> moduleDependees = smodule.getDependSubsystems();
        String ourSubSystem = subSysMod.getSubSystem();
        if (moduleDependees.contains(ourSubSystem)) {
        }
    }
}

```

# 4.4.9 Позиционные маркеры

Пример:

`// Действия //////////////`

Такие заголовки привлекают внимание только, если они встречаются не слишком часто. Используйте, только если приносят
ощутимую пользу. При злоупотреблении они воспринимаются как фоновый шум.

# 4.4.10 Комментарии за закрывающей фигурной скобкой

Если функция имеет многоуровневые вложенности, то такие комментарии позволяют понять, чему принадлежит закрывающаяся
скобка.

```java
class Main {
    public static void main(String[] args) {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        String line;
        int lineCount = 0;
        int charCount = 0;
        int wordCount = 0;
        try {
            while ((line = in.readLine()) != null) {
                lineCount++;
                charCount += line.length();
                String words[] = line.split("\\W");
                wordCount += words.length;
            } // while
            System.out.println("wordCount = " + wordCount);
            System.out.println("lineCount = " + lineCount);
            System.out.println("charCount = " + charCount);
        } // try
        catch (IOException e) {
            System.err.println("Error:" + e.getMessage());
        } // catch
    } // main
}

```

Следует разделить такие функции на несколько и в подобных комментариях не будет нужды.

# 4.4.11 Ссылки на авторов

`/* Добавлено Риком*/`

С появлением систем контроля, в которой более подробно указано, кто работал с кодом, нет причин указывать такие
комментарии. Со временем с кодом работают много авторов, а тот код который писал автор - больше нет и комментарий
остается не актуальные.

# 4.4.12 Закомментированный код

Не оставляйте закомментированный код, с появлением современных средств контроля версий его можно восстановить. Имейте
храбрость удалить закомментированный код, если его увидели.

# 4.4.13 Комментарии HTML

HTML в комментариях захламляет файл исходного кода. Если комментарии должны извлекаться внешними инструментами, например
Javadoc, для отображения в веб-странице, то за украшение комментариев соответствующим кодом HTML должен отвечать этот
инструмент, а не программист.

# 4.4.14 Нелокальная информация

Комментарий должен описывать код, который находится поблизости, а не описывать информацию системного уровня.

# 4.4.15 Слишком много информации

Не включайте в комментарии интересные исторические дискуссии или описания подробностей, достаточно указать ссылку на
статью/стандарт/stackoverflow.

# 4.4.16 Неочевидные комментарии

Связь между комментарием и кодом, который он описывает, должна быть очевидной. Цель комментария - объяснить код, который
не объяснит сам себя. Плохо, когда сам комментарий нуждается в объяснении.

# 4.4.17 Заголовки функций

Короткие функции не нуждаются в долгих описаниях. Хорошо выбранное имя компактной функции, лучше заголовка.

# 4.4.18 Заголовки Javadoc во внутреннем коде

Применяйте комментарии Javadoc только для API общего пользования. Генерирование Javadoc для внутренних классов и функций
не приносит реальной пользы, а формализм только отвлекает.

# 5 Форматирование

# 5.1 Цель форматирования

# 5.1.1 Вертикальное форматирование