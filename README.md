# Краткое содержание "Чистый код: создание, анализ и рефакторинг", Роберт Мартин

## Описание

Это мой конспект
книги ["Чистый код: создание, анализ и рефакторинг", Роберт Мартин](https://www.piter.com/collection/all/product/chistyy-kod-sozdanie-analiz-i-refaktoring-biblioteka-programmista-45ccca) (
сайт российского издательства).

Если Вы автор и считаете, что данный конспект нарушает авторские права - прошу сообщить, я сделаю этот репозиторий
приватным.

Нашли опечатку/неточность? Пишите - разберемся.

[Связаться со мной](https://t.me/szachesov)

# 1 Содержание

- [1 Содержание](#1-содержание)
- [2 Содержательные имена](#2-содержательные-имена)
    - [2.1 Имена должны передавать намерения программиста](#21-имена-должны-передавать-намерения-программиста)
    - [2.2 Избегайте дезинформации](#22-избегайте-дезинформации)
    - [2.3 Используйте осмысленные различия](#23-используйте-осмысленные-различия)
    - [2.4 Используйте удобопроизносимые имена](#24-используйте-удобопроизносимые-имена)
    - [2.5 Выбирайте имена, удобные для поиска](#25-выбирайте-имена-удобные-для-поиска)
    - [2.6 Избегайте схем кодирования имен](#26-избегайте-схем-кодирования-имен)
        - [2.6.1 Венгерская запись](#261-венгерская-запись)
        - [2.6.2 Префиксы членов классов](#262-префиксы-членов-классов)
        - [2.6.3 Интерфейсы и реализации](#263-интерфейсы-и-реализации)
    - [2.7 Избегайте мысленных преобразований](#27-избегайте-мысленных-преобразований)
    - [2.8 Имена классов](#28-имена-классов)
    - [2.9 Имена методов](#29-имена-методов)
    - [2.10 Избегайте остроумия](#210-избегайте-остроумия)
    - [2.11 Выберите одно слово для каждой концепции](#211-выберите-одно-слово-для-каждой-концепции)
    - [2.12 Воздержитесь от каламбуров](#212-воздержитесь-от-каламбуров)
    - [2.13 Используйте имена из пространства решения](#213-используйте-имена-из-пространства-решения)
    - [2.14 Используйте имена из пространства задач](#214-используйте-имена-из-пространства-задач)
    - [2.15 Добавьте содержательный контекст](#215-добавьте-содержательный-контекст)
    - [2.16 Не добавляйте избыточный контекст](#216-не-добавляйте-избыточный-контекст)
- [3 Функции](#3-функции)
    - [3.1 Компактность!](#31-компактность)
        - [3.1.1 Блоки и отступы](#311-блоки-и-отступы)
    - [3.2 Правило одной функции](#32-правило-одной-функции)
        - [3.2.1 Секции в функциях](#321-секции-в-функциях)
    - [3.3 Один уровень абстракции на функцию](#33-один-уровень-абстракции-на-функцию)
        - [3.3.1 Чтение кода сверху вниз: правило понижения](#331-чтение-кода-сверху-вниз-правило-понижения)
    - [3.4 Команды switch](#34-команды-switch)
    - [3.5 Используйте содержательные имена](#35-используйте-содержательные-имена)
    - [3.6 Аргументы функций](#36-аргументы-функций)
        - [3.6.1 Стандартные унарные формы](#361-стандартные-унарные-формы)
        - [3.6.2 Аргументы-флаги](#362-аргументы-флаги)
        - [3.6.3 Бинарные функции](#363-бинарные-функции)
        - [3.6.4 Тернарные функции](#364-тернарные-функции)
        - [3.6.5 Объекты как аргументы](#365-объекты-как-аргументы)
        - [3.6.6 Списки аргументов](#366-списки-аргументов)
        - [3.6.7 Глаголы и ключевые слова](#367-глаголы-и-ключевые-слова)
    - [3.7 Избавьтесь от побочных эффектов](#37-избавьтесь-от-побочных-эффектов)
        - [3.7.1 Выходные аргументы](#371-выходные-аргументы)
    - [3.8 Разделение команд и запросов](#38-разделение-команд-и-запросов)
    - [3.9 Используйте исключения вместо возращения кодов ошибок](#39-используйте-исключения-вместо-возращения-кодов-ошибок)
        - [3.9.1 Изолируйте блоки try|catch](#391-изолируйте-блоки-trycatch)
        - [3.9.2 Обработка ошибок как одна операция](#392-обработка-ошибок-как-одна-операция)
    - [3.10 Магнит зависимостей Error.java](#310-магнит-зависимостей-errorjava)
    - [3.11 Не повторяйтесь](#311-не-повторяйтесь)
    - [3.12 Структурное программирование](#312-структурное-программирование)
    - [3.13 Как научиться писать такие функции?](#313-как-научиться-писать-такие-функции)
    - [3.14 Завершение](#314-завершение)
- [4 Комментарии](#4-комментарии)
    - [4.1 Комментарии не компенсируют плохого кода](#41-комментарии-не-компенсируют-плохого-кода)
    - [4.2 Объясните свои намерения в коде](#42-объясните-свои-намерения-в-коде)
    - [4.3 Хорошие комментарии](#43-хорошие-комментарии)
        - [4.3.1 Юридические комментарии](#431-юридические-комментарии)
        - [4.3.2 Информативные комментарии](#432-информативные-комментарии)
        - [4.3.3 Представление намерений](#433-представление-намерений)
        - [4.3.4 Прояснение](#434-прояснение)
        - [4.3.5 Предупреждения о последствиях](#435-предупреждения-о-последствиях)
        - [4.3.6 Комментарии TODO](#436-комментарии-todo)
        - [4.3.7 Усиление](#437-усиление)
        - [4.3.8 Комментарии Javadoc в общедоступных API](#438-комментарии-javadoc-в-общедоступных-api)
    - [4.4 Плохие комментарии](#44-плохие-комментарии)
        - [4.4.1 Бормотание](#441-бормотание)
        - [4.4.2 Избыточные комментарии](#442-избыточные-комментарии)
        - [4.4.3 Недостоверные комментарии](#443-недостоверные-комментарии)
        - [4.4.4 Обязательные комментарии](#444-обязательные-комментарии)
        - [4.4.5 Журнальные комментарии](#445-журнальные-комментарии)
        - [4.4.6 Шум](#446-шум)
        - [4.4.7 Опасный шум](#447-опасный-шум)
        - [4.4.8 Не используйте комментарии там, где можно использовать функцию или переменную](#448-не-используйте-комментарии-там-где-можно-использовать-функцию-или-переменную)
        - [4.4.9 Позиционные маркеры](#449-позиционные-маркеры)
        - [4.4.10 Комментарии за закрывающей фигурной скобкой](#4410-комментарии-за-закрывающей-фигурной-скобкой)
        - [4.4.11 Ссылки на авторов](#4411-ссылки-на-авторов)
        - [4.4.12 Закомментированный код](#4412-закомментированный-код)
        - [4.4.13 Комментарии HTML](#4413-комментарии-html)
        - [4.4.14 Нелокальная информация](#4414-нелокальная-информация)
        - [4.4.15 Слишком много информации](#4415-слишком-много-информации)
        - [4.4.16 Неочевидные комментарии](#4416-неочевидные-комментарии)
        - [4.4.17 Заголовки функций](#4417-заголовки-функций)
        - [4.4.18 Заголовки Javadoc во внутреннем коде](#4418-заголовки-javadoc-во-внутреннем-коде)
- [5 Форматирование](#5-форматирование)
    - [5.1 Цель форматирования](#51-цель-форматирования)
        - [5.1.1 Вертикальное форматирование](#511-вертикальное-форматирование)
        - [5.1.2 Газетная метафора](#512-газетная-метафора)
        - [5.1.3 Вертикальное разделение концепций](#513-вертикальное-разделение-концепций)
        - [5.1.4 Вертикальное сжатие](#514-вертикальное-сжатие)
        - [5.1.5 Вертикальное расстояние](#515-вертикальное-расстояние)
        - [5.1.6 Вертикальное упорядочение](#516-вертикальное-упорядочение)
    - [5.2 Горизонтальное форматирование](#52-горизонтальное-форматирование)
        - [5.2.1 Горизонтальное разделение и сжатие](#521-горизонтальное-разделение-и-сжатие)
        - [5.2.2 Горизонтальное выравнивание](#522-горизонтальное-выравнивание)
        - [5.2.3 Отступы](#523-отступы)
        - [5.2.4 Вырожденные области видимости](#524-вырожденные-области-видимости)
        - [5.2.5 Правила форматирования в группах](#525-правила-форматирования-в-группах)
- [6 Объекты и структуры данных](#6-объекты-и-структуры-данных)
    - [6.1 Абстракция данных](#61-абстракция-данных)
    - [6.2 Антисимметрия данных/объектов](#62-антисимметрия-данныхобъектов)
    - [6.3 Закон Деметры](#63-закон-деметры)
        - [6.3.1 Крушение поезда](#631-крушение-поезда)
        - [6.3.2 Гибриды](#632-гибриды)
        - [6.3.2 Гибриды](#632-гибриды)
        - [6.3.3 Скрытие структуры](#633-скрытие-структуры)
        - [6.3.4 Объекты передачи данных](#634-объекты-передачи-данных)
        - [6.3.5 Активные записи](#635-активные-записи)
- [7 Обработка ошибок](#7-обработка-ошибок)
    - [7.1 Используйте исключения вместо кодов ошибок](#71-используйте-исключения-вместо-кодов-ошибок)
    - [7.2 Начните с написания команды try-catch-finally](#72-начните-с-написания-команды-try-catch-finally)
    - [7.3 Используйте непроверяемые исключения](#73-используйте-непроверяемые-исключения)
    - [7.4 Передавайте контекст с исключениями](#74-передавайте-контекст-с-исключениями)
    - [7.5 Определяйте классы исключений в контексте потребностей вызывающей стороны](#75-определяйте-классы-исключений-в-контексте-потребностей-вызывающей-стороны)
    - [7.6 Определите нормальный путь выполнения](#76-определите-нормальный-путь-выполнения)
    - [7.7 Не возвращайте null](#77-не-возвращайте-null)
    - [7.8 Не передавайте null](#78-не-передавайте-null)
- [8 Границы](#8-границы)
    - [8.1 Использование стороннего кода](#81-использование-стороннего-кода)
    - [8.2 Исследование и анализ границ](#82-исследование-и-анализ-границ)
        - [8.2.1 Изучение log4j](#821-изучение-log4j)
        - [8.2.2 Учебные тесты: выгоднее, чем бесплатно](#822-учебные-тесты-выгоднее-чем-бесплатно)
        - [8.2.3 Использование несуществующего кода](#823-использование-несуществующего-кода)
- [9 Модульные тесты](#9-модульные-тесты)
    - [9.1 Три закона TDD](#91-три-закона-tdd)
    - [9.2 О чистоте тестов](#92-о-чистоте-тестов)
        - [9.2.1 Тесты как средство обеспечения изменений](#921-тесты-как-средство-обеспечения-изменений)
    - [9.3 Чистые тесты](#93-чистые-тесты)
        - [9.3.1 Предметно-ориентированный язык тестирования](#931-предметно-ориентированный-язык-тестирования)
        - [9.3.2 Двойной стандарт](#932-двойной-стандарт)
    - [9.4 Одна проверка на тест](#94-одна-проверка-на-тест)
        - [9.4.1 Одна концепция на тест](#941-одна-концепция-на-тест)
    - [9.5 F.I.R.S.T.](#95-first)
- [10 Классы](#10-классы)
    - [10.1 Строение класса](#101-строение-класса)
        - [10.1.1 Инкапсуляция](#1011-инкапсуляция)
        - [10.1.2 Классы должны быть компактными!](#1012-классы-должны-быть-компактными)
        - [10.1.3 Принцип единой ответственности (SRP)](#1013-принцип-единой-ответственности-srp)
        - [10.1.4 Связность](#1014-связность)
        - [10.1.5 Поддержание связности приводит к уменьшению классов](#1015-поддержание-связности-приводит-к-уменьшению-классов)
    - [10.2 Структурирование с учетом изменений](#102-структурирование-с-учетом-изменений)
        - [10.2.1 Изоляция изменения](#1021-изоляция-изменения)
- [11 Системы](#11-системы)
    - [11.1 Отделение конструирования системы от её использования](#111-отделение-конструирования-системы-от-её-использования)
    - [11.2 Отделение main](#112-отделение-main)
        - [11.2.2 Фабрики](#1121-фабрики)
        - [11.2.2 Внедрение зависимостей](#1122-внедрение-зависимостей)
    - [11.3 Масштабирование](#113-масштабирование)
        - [11.3.1 Поперечные области ответственности](#1131-поперечные-области-ответственности)
    - [11.4 Посредники](#114-посредники)
    - [11.5 АОП-инфраструктуры на "чистом" Java](#115-аоп-инфраструктуры-на-чистом-java)
    - [11.6 Аспекты AspectJ](#116-аспекты-aspectj)
    - [11.7 Испытание системной архитектуры](#117-испытание-системной-архитектуры)
    - [11.8 Оптимизация принятия решений](#118-оптимизация-принятия-решений)
    - [11.9 Применяйте стандарты разумно, когда они приносят очевидную пользу](#119-применяйте-стандарты-разумно-когда-они-приносят-очевидную-пользу)
        - [11.9.1 Системам необходимы предметно-ориентированные языки](#1191-системам-необходимы-предметно-ориентированные-языки)
- [12 Формирование архитектуры](#12-формирование-архитектуры)
    - [12.1 Четыре правила](#121-четыре-правила)
        - [12.1.1 Правило №1: выполнение всех тестов](#1211-правило-1-выполнение-всех-тестов)
        - [12.1.2 Правило №2-4: переработка кода](#1212-правило-2-4-переработка-кода)
            - [12.1.2.1 Отсутствие дублирования](#12121-отсутствие-дублирования)
            - [12.1.2.2 Выразительность](#12122-выразительность)
            - [12.1.2.3 Минимум классов и методов](#12123-минимум-классов-и-методов)
- [13 Многопоточность](#13-многопоточность)
    - [13.1 Зачем нужна многопоточность?](#131-зачем-нужна-многопоточность)
        - [13.1 Мифы и неверные представления](#1311-мифы-и-неверные-представления)
    - [13.2 Трудности](#132-трудности)
    - [13.3 Защита от ошибок многопоточности](#133-защита-от-ошибок-многопоточности)
        - [13.3.1 Принцип единой ответственности](#1331-принцип-единой-ответственности)
        - [13.3.2 Следствие: ограничивайте область видимости данных](#1332-следствие-ограничивайте-область-видимости-данных)
        - [13.3.3 Следствие: потоки должны быть как можно более независимы](#1333-следствие-потоки-должны-быть-как-можно-более-независимы)
    - [13.4 Знайте свою библиотеку](#134-знайте-свою-библиотеку)
        - [13.4.1 Потоково-безопасные коллекции](#1341-потоково-безопасные-коллекции)
    - [13.5 Знайте модели выполнения](#135-знайте-модели-выполнения)
        - [13.5.1 Модель "производитель-потребитель"](#1351-модель-производитель-потребитель)
        - [13.5.2 Модель "читатели-писатели"](#1352-модель-читатели-писатели)
        - [13.5.3 Модель "обедающих философов"](#1353-модель-обедающих-философов)
    - [13.6 Остерегайтесь зависимостей между синхронизированными методами](#136-остерегайтесь-зависимостей-между-синхронизированными-методами)
    - [13.7 Синхронизированные секции должны иметь минимальный размер](#137-синхронизированные-секции-должны-иметь-минимальный-размер)
    - [13.8 О трудности корректного завершения](#138-о-трудности-корректного-завершения)
    - [13.9 Тестирование многопоточного кода](#139-тестирование-многопоточного-кода)
        - [13.9.1 Рассматривайте непериодические сбои как признаки возможных проблем многопоточности](#1391-рассматривайте-непериодические-сбои-как-признаки-возможных-проблем-многопоточности)
        - [13.9.2 Начинайте с отладки основного кода, не связанного с многопоточным](#1392-начинайте-с-отладки-основного-кода-не-связанного-с-многопоточным)
        - [13.9.3 Реализуйте переключение конфигураций многопоточного кода](#1393-реализуйте-переключение-конфигураций-многопоточного-кода)
        - [13.9.4 Обеспечьте логическую изоляцию конфигураций многопоточного кода](#1394-обеспечьте-логическую-изоляцию-конфигураций-многопоточного-кода)
        - [13.9.5 Протестируйте программу с количеством потоков, превышающим количество процессоров](#1395-протестируйте-программу-с-количеством-потоков-превышающим-количество-процессоров)
        - [13.9.6 Протестируйте программу на разных платформах](#1396-протестируйте-программу-на-разных-платформах)
        - [13.9.7 Применяйте инструмент кода для повышения вероятности сбоев](#1397-применяйте-инструмент-кода-для-повышения-вероятности-сбоев)
            - [13.9.7.1 Ручная инструментовка](#13971-ручная-инструментовка)
            - [13.9.7.2 Автоматизированная инструментовка](#13972-автоматизированная-инструментовка)
- [14 Последовательное очищение](#14-последовательное-очищение)
    - [14.1 Реализация Args](#141-реализация-args)
    - [14.2 Как я это сделал?](#142-как-я-это-сделал)
    - [14.3 Args: черновик](#143-args-черновик)
        - [14.3.1 На этом я остановился](#1431-на-этом-я-остановился)
        - [14.3.2 О постепенном усовершенствовании](#1432-о-постепенном-усовершенствовании)
    - [14.4 Последовательное очищение](#144-последовательное-очищение)
- [15 Внутреннее строение JUnit](#15-внутреннее-строение-junit)
- [16 Переработка SerialDate](#16-переработка-serialdate)
- [17 Запахи и эвристические правила](#17-запахи-и-эвристические-правила)
    - [17.1 Комментарии](#171-комментарии)
        - [C1: Неуместная информация](#c1-неуместная-информация)
        - [C2: Устаревшая информация](#c2-устаревшая-информация)
        - [C3: Избыточная информация](#c3-избыточная-информация)
        - [C4: Плохо написанный комментарий](#c4-плохо-написанный-комментарий)
        - [C5: Закомментированный код](#c5-закомментированный-код)
    - [17.2 Функции](#172-функции)
        - [F1: Слишком много аргументов](#f1-слишком-много-аргументов)
        - [F2: Выходные аргументы](#f2-выходные-аргументы)
        - [F3: Флаг в аргументах](#f3-флаг-в-аргументах)
        - [F4: Мертвые функции](#f4-мертвые-функции)
    - [17.3 Разное](#173-разное)
        - [G1: Несколько языков в одном исходном файле](#g1-несколько-языков-в-одном-исходном-файле)
        - [G2: Очевидное поведение не реализовано](#g2-очевидное-поведение-не-реализовано)
        - [G3: Некорректное граничное условие](#g3-некорректное-граничное-условие)
        - [G4: Отключенные средства безопасности](#g4-отключенные-средства-безопасности)
        - [G5: Дублирование](#g5-дублирование)
        - [G6: Код на неверном уровне абстракции](#g6-код-на-неверном-уровне-абстракции)
        - [G7: Базовые классы, зависящие от производных](#g7-базовые-классы-зависящие-от-производных)
        - [G8: Слишком много информации](#g8-слишком-много-информации)
        - [G9: Мертвый код](#g9-мертвый-код)
        - [G10: Вертикальное разделение](#g10-вертикальное-разделение)
        - [G11: Непоследовательность](#g11-непоследовательность)
        - [G12: Балласт](#g12-балласт)
        - [G13: Искусственные привязки](#g13-искусственные-привязки)
        - [G14: Функциональная зависть](#g14-функциональная-зависть)
        - [G15: Аргументы-селекторы](#g15-аргументы-селекторы)
        - [G16: Непонятные намерения](#g16-непонятные-намерения)
        - [G17: Неверное размещение](#g17-неверное-размещение)
        - [G18: Неуместные статические методы](#g18-неуместные-статические-методы)
        - [G19: Используйте пояснительные переменные](#g19-используйте-пояснительные-переменные)
        - [G20: Имена функций должны описывать выполняемую операцию](#g20-имена-функций-должны-описывать-выполняемую-операцию)
        - [G21: Понимание алгоритма](#g21-понимание-алгоритмов)
        - [G22: Преобразование логических зависимостей в физические](#g22-преобразование-логических-зависимостей-в-физические)
        - [G23: Используйте полиморфизм вместо if/else или switch/case](#g23-используйте-полиморфизм-вместо-ifelse-или-switchcase)
        - [G24: Соблюдайте стандартные конвенции](#g24-соблюдайте-стандартные-конвенции)
        - [G25: Заменяйте "волшебные числа" именованными константами](#g25-заменяйте-волшебные-числа-именованными-константами)
        - [G26: Будьте точны](#g26-будьте-точны)
        - [G27: Структура важнее конвенций](#g27-структура-важнее-конвенций)
        - [G28: Инкапсулируйте условные конструкции](#g28-инкапсулируйте-условные-конструкции)
        - [G29: Избегайте отрицательных условий](#g29-избегайте-отрицательных-условий)
        - [G30: Функции должны выполнять одну операцию](#g30-функции-должны-выполнять-одну-операцию)
        - [G31: Скрытые временные привязки](#g31-скрытые-временные-привязки)
        - [G31: Структура кода должна быть обоснована](#g32-структура-кода-должна-быть-обоснована)
        - [G33: Инкапсулируйте граничные условия](#g33-инкапсулируйте-граничные-условия)
        - [G34: Функции должны быть написаны на одном уровне абстракции](#g34-функции-должны-быть-написаны-на-одном-уровне-абстракции)
        - [G35: Храните конфигурационные данные на высоких уровнях](#g35-храните-конфигурационные-данные-на-высоких-уровнях)
        - [G36: Избегайте транзитивных обращений](#g36-избегайте-транзитивных-обращений)
    - [17.4 Java](#174-java)
        - [J1: Используйте обобщенные директивы импорта](#j1-используйте-обобщенные-директивы-импорта)

# 2 Содержательные имена

## 2.1 Имена должны передавать намерения программиста

Следите за именами и изменяйте их, если найдете более удачные варианты.

Имя переменной, функции или класса должно сообщить, почему существует эта сущность, что она делает и как используется.
Если имя требует комментарии - оно не передает намерения программиста.

Не выразительные имена:

```java
public class Minesweeper {
    public List<int[]> getThem() {
        List<int[]> list1 = new ArrayList<>();
        for (int[] x : theList) {
            if (x[0] == 4) {
                list1.add(x);
            }
        }
        return list1;
    }
}

```

Добавление имен, на примере игры "Сапер":

```java
public class Minesweeper {
    public List<int[]> getFlaggedCells() {
        List<int[]> flaggedCells = new ArrayList<>();
        for (int[] cell : gameBoard) {
            if (x[STATUS_VALUE] == FLAGGED) {
                flaggedCells.add(cell);
            }
        }
        return flaggedCells;
    }
}

```

Добавление класса, для описания ячеек:

```java
public class Minesweeper {
    public List<Cell> getFlaggedCells() {
        List<Cell> flaggedCells = new ArrayList<>();
        for (Cell cell : gameBoard) {
            if (cell.isFlagged()) {
                flaggedCells.add(cell);
            }
        }
        return flaggedCells;
    }
}

```

## 2.2 Избегайте дезинформации

Нужно избегать ложных ассоциаций, затемняющий смысл кода. Не используйте слова со скрытыми значениями, отличными от
предполагаемого.

Обозначение группы ученых. Плохо: `accountList`, если только действительно не используется `List`.
Лучше: `accountGroup`, `bunchOfAccounts`, `accounts`.

Остерегайтесь малозаметных различий в именах: `XYZControllerForEfficientHandlingOfStrings`
и `XYZControllerForEfficientStorageOfStrings`.

Избегайте использование строчно `L` и прописной `O` в названиях переменной, поскольку они почти не отличаются от `1`
и `0` соответственно.

## 2.3 Используйте осмысленные различия

"Числовые ряды" (a1, a2 ... aN) такие имена не дезинформируют, но не несут никакой информации.

Не информативные слова в названиях:

* слова для создания бессодержательных различий: классы `ProductInfo` или `ProductData`
* слово `variable` для имен переменных, `table` в именах таблиц и тп
* название типа `nameString`, для переменной которая будет навряд ле будет не строковым значением
* дополнительное слово `Object` в названии класса

## 2.4 Используйте удобопроизносимые имена

Например, не надо называть переменные не общеизвестной аббревиатурой или сокращать: `genymdhms` (дата генерирования,
год, месяц, день, час, минуты и секунды) или `modymdhms` (дата модификации, год, месяц, день, час, минуты и секунды),
лучше `generationTimestamp` и `modificationTimestamp` соответственно.

## 2.5 Выбирайте имена, удобные для поиска

Трудно искать в большом объеме текса однобуквенные переменные и числовые константы.

Буква `e` - самая распространенная буква английского алфавита, не стоит присваивать её имени переменной. Трудно будет
найти в тексте.

Однобуквенные переменные могут использоваться ТОЛЬКО для локальных переменных. Длина имени должна соответствовать
размеру его области видимости.

## 2.6 Избегайте схем кодирования имен

У программистов и так хватает хлопот с кодированием.

## 2.6.1 Венгерская запись

Было распространено в старых языках программирования, когда были ограничения на длину имени или невозможность объявить
тип переменной. Современные языки существует развитая система типов, а компиляторы запоминают их и обеспечивают их
соблюдение.

## 2.6.2 Префиксы членов классов

Классы и функции должны быть достаточно компактными, чтобы могли обходиться без префиксов.

## 2.6.3 Интерфейсы и реализации

Если есть выбор добавления кодирования в интерфейсы или классы, чтобы имена не дублировались,
например, `interface IShapeFactory` или `class ShapeFactoryImpl`. Лучше выбрать класс, чтобы не сообщать пользователю,
что имеют дело с интерфейсов, в том числе из-за полиморфного использования типов переменных.

## 2.7 Избегайте мысленных преобразований

Не заставляйте читателя мысленно преобразовывать ваши имена в другие. Как правило, такие проблемы происходят с именами
переменной однобуквенными или сокращенными, особенно если используется не в ограниченной области видимости.

## 2.8 Имена классов

* Должны быть существительные и их комбинации: `WikiPage`, `AddressParser`
* Стараться не использовать такие слова в именах `Manager`, `Processor`, `Data` или `Info`
* Имена не должны быть глаголом

## 2.9 Имена методов

* Должны быть глаголы или глагольные словосочетания: `postPayment`, `deletePage`, `save` и т.д.
* Методы чтения/записи и предикаты образуются из значений и префиксов: `get`, `set`, `is` согласно `javabean`
* При перезагрузке конструкторов предпочесть статистические методы-фабрики с именами, описывающие
  аргументы: `Complex fulcrumPoint = Complex.fromRealNumber(23.0)`, лучше `Complex fulcrumPoint = new Complex(23.0)`

## 2.10 Избегайте остроумия

Отдавайте предпочтение ясности перед развлекательной ценностью, а также формы просторечия или сленга.

## 2.11 Выберите одно слово для каждой концепции

Выберите одно слово для представления одной абстрактной концепции и придерживайтесь его. Существование в разных классах
эквивалентных методов с именами `fetch`, `retrieve` и `get` создаст путаницу.
Использование терминов `controller`, `manager` и `driver` в одной кодовой базе может вызвать путаницу.

## 2.12 Воздержитесь от каламбуров

Старайтесь не использовать одно слово в двух смыслах. Обозначение двух разных идей одним терминов - каламбур.
Например, существуют классы с именем метода `add`, который создает объект-значение с помощью сложение. То не следует в
другой класс называть метод `add` который добавляет объект в коллекцию, поскольку он имеет другую семантику, лучше
назвать его `insert` или `append`.

## 2.13 Используйте имена из пространства решения

Код читают программиста, поэтому можно использовать термины из области информатики, названия алгоритмов и паттернов,
математические термины и тп. Например, `JobQueue` - "очередь задач". Не ограничивайте именами только из пространства
конкретной задачи.

## 2.14 Используйте имена из пространства задач

Если нет подходящего имени из пространства решения, можно использовать имя из пространства конкретной задачи.

## 2.15 Добавьте содержательный контекст

Мало имен, которые содержательны сами по себе. Все остальные следует помещать в контекст для читателя кода, заключая их
в классы, функции и пространства имен. В крайнем случае контекст имени можно уточнить при помощи
префикса: `firstName`, `lastName`.

Имя функции определяет только часть контекста, остальное определяет сам алгоритм:

```java
public class Main {
    private void printGuessStatistics(char candidate, int count) {
        String number;
        String verb;
        String pluralModifier;

        if (count == 0) {
            number = "no";
            verb = "are";
            pluralModifier = "s";
        } else if (count == 1) {
            number = "1";
            verb = "is";
            pluralModifier = "";
        } else {
            number = Integer.toString(count);
            verb = "are";
            pluralModifier = "s";
        }

        String guessMessage =
                String.format("There %s %s %s%s", verb, number, candidate, pluralModifier);
        print(guessMessage);
    }
}

```

Функция выше длинная, переменные используются на все её протяжении.

Чтобы сократить функцию, можно вынести логику функции в класс, предоставляя очевидный контекст для переменных, а также
улучшить четкость алгоритма за счет деления на меньшие функции:

```java
public class GuessStatisticsMessage {
    private String number;
    private String verb;
    private String pluralModifier;

    public String make(char candidate, int count) {
        createPluralDependentMessageParts(count);
        return String.format("There %s %s %s%s", verb, number, candidate, pluralModifier);
    }

    private void createPluralDependentMessageParts(int count) {
        if (count == 0) {
            thereAreNoLetters();
        } else if (count == 1) {
            thereIsOneLetter();
        } else {
            thereAreManyLetters(count);
        }
    }

    private void thereAreNoLetters(int count) {
        number = Integer.toString(count);
        verb = "are";
        pluralModifier = "s";
    }

    private void thereIsOneLetter() {
        number = "1";
        verb = "is";
        pluralModifier = "";
    }

    private void thereAreNoLetters() {
        number = "no";
        verb = "are";
        pluralModifier = "s";
    }
}

```

## 2.16 Не добавляйте избыточный контекст

Если название приложение, например "Gas Station Deluxe", то не надо добавлять к имени каждого класса `GSD`.

Короткие имена обычно лучше длинных, если только их смысл понятен читателю кода. Не включайте в имя больше контекст, чем
необходимо.

Имена `accountAddress` и `customerAddress` хорошо подходят для экземпляров класса `Address`, но не для имен классов.
Если потребуется подчеркнуть, например, различия между MAC-адресами, адресами портов и веб-адресами, можно классы
назвать именами `PostalAddress`, `Mac`, `Url`.

# 3 Функции

## 3.1 Компактность!

Желательно, функция не должна превышать 20 строк. В идеале 2-4 строки.

### 3.1.1 Блоки и отступы

* В блоках `if`, `else`, `while` и т.д. должны состоять из одной строчки, в которой обычно вызывается функция. Вмещающая
  функция становится компактной и документируется код
* Функции не должны содержать вложенных структур (C++)
* Максимальный уровень отступов в функциях - 1-2

## 3.2 Правило одной функции

Функция должна выполнять только одну операцию. Она должна выполнят её хорошо. И ничего другого она делать не должна.

Если функция выполняет только те действия, которые находятся на одном уровне под объявленным именем функции, то эта
функция выполняет одну операцию.

Если команду `if` вынести в отдельную функцию с именем `includeSetupAndTeardownIfTestPages`, то это простая
переформулировка кода без изменения уровня абстракции.

```java
class Main {

    public static String renderPageWithSetupsAndTeardowns(PageData pageData, boolean isSuite) {
        if (isTestPage(pageData)) {
            includeSetupAndTeardownPages(pageData, isSuite);
        }
        return pageData.getHtml();
    }
}

```

Чтобы определить, что функция выполняет только одну операцию, попробуйте извлечь из неё другую функцию, которая являлась
простой переформулировкой реализации.

### 3.2.1 Секции в функциях

Функцию, выполняющую только одну операцию, невозможно осмысленно разделить на секции.

## 3.3 Один уровень абстракции на функцию

Что бы функции выполняли только одну операцию, все команды кода должны быть на одном уровне абстракции.

_Пример уровней абстракции: подключение к бд (низкий), CRUD работа с бд (средний), отправка конкретной формы (высокий)_

### 3.3.1 Чтение кода сверху вниз: правило понижения

Код должен читаться как рассказ - сверху вниз.

Правило понижения - когда каждая функция находится на одном уровне абстракции и можно читать код последовательно,
спускаясь по уровням.

## 3.4 Команды switch

Если требуется применить команду `switch`, можно скрыть её на низкоуровнем классе и не дублировать в коде, в этом
поможет полиморфизм.

```java
class Main {

    public Money calculatePay(Employee e) throws InvalidEmployeeType {
        switch (e.type) {
            case COMMISSIONED:
                return calculateCommissionedPay(e);
            case HOURLY:
                return calculateHourlyPay(e);
            case SALARIED:
                return calculateSalariedPay(e);
            default:
                throw new InvalidEmployeeType(e);
        }
    }
}

```

Недостатки:

1. Функция велика и при добавлении новых типов - разрастется
2. Выполняет более одной операции
3. Нарушает принцип "единой ответственности"
4. Нарушает принцип "открытости/закрытности", код должен изменяться при каждом добавлении новой функции

Решение: перемести команду `switch` в абстрактную фабрику.

```java
public abstract class Employee {
    abstract boolean isPayday();

    abstract Money calculatePay();

    abstract void deliverPay(Money pay);
}

public interface EmployeeFactory {
    Employee makeEmployee(EmployeeRecod r) throws InvalidEmployeeType;
}

public class EmployeeFactoryImpl implements EmployeeFactory {
    Employee makeEmployee(EmployeeRecod r) throws InvalidEmployeeType {
        switch (e.type) {
            case COMMISSIONED:
                return new CommissionedEmployee(r);
            case HOURLY:
                return new HourlyEmployee(r);
            case SALARIED:
                return new SalariedEmploye(r);
            default:
                throw new InvalidEmployeeType(r.type);
        }
    }
}

```

Команда `switch` допустимы, если они встречаются в программе однократно, используются для создания полиморфных объектов
и скрываются за отношениями наследования, чтобы оставаться невидимыми для остальных частей программы.

_В java11 можно воспользоваться более компактной записью `switch`. Решение в `Java. Эффективное программированиме`
насчет `switch` и `enum` более элегантное, по моему мнению._

## 3.5 Используйте содержательные имена

Длинное содержательное имя лучше короткого невразумительного. Выберете схему, которая позволить легко прочитать слова в
имени. Затем составьте из этих слов имя, которое описывает назначение функции.
Не бойтесь расходовать время на выбор имени. Опробуйте несколько разных имен и посмотрите, как читается кода с каждым из
вариантов.
Используйте в именах функций те же словосочетания, глаголы и существительные, которые используются в ваших модулях.

## 3.6 Аргументы функций

В идеале кол-во аргументов функции равно нулю. Функции с тремя аргументами следует избегать. Необходимость большего
кол-во аргументов должна подкреплена очень вескими доводами.

Если аргументов больше двух, задача тестирования всех возможных комбинаций выглядит все более устрашающе.

Обычно предполагается, что функция получает информацию в аргументах, и выдает её в возвращаемом значении. Как правило,
никто не ожидает, что функция будет возвращать информацию в аргументах.

### 3.6.1 Стандартные унарные формы

Случаи вызова функции с одним аргументом:

1. Проверка некоторого условия, связанного с аргументом, например `boolean fileExists("MyFile")`
2. Обработка аргумента, его преобразование и возращение, например `InputStream fileOpen("MyFile")`
3. (Редкий) Событие - программа интерпретирует вызов функции как событие и использует аргумент для изменения состояния
   системы, например `void passwordAttemptFailedNtimes(int attempts)`

Стараться избегать унарных функций, не относящиеся к этим формам, например `void transform(StringBuffer in)`
преобразовывает входной аргумент, лучше добавить возражающее значение `StringBuffer transform(StringBuffer out)`.

### 3.6.2 Аргументы-флаги

Старайтесь не использовать аргументы-флаги. Такая функция будет выполнять более одной операции. Лучше разбить функцию на
две.

### 3.6.3 Бинарные функции

Функции с двумя аргументами менее предпочтительно, чем с одним. Стоит, по возможности преобразовать в унарные.

В некоторых случаях они являются логичными, например `Point p = new Point(0, 0)`, в данном случае они являются
упорядоченными компонентами одного значения.

`writeField(outputStream, name)` - аргументы не имеют ни естественной связи, ни естественного порядка. В данном случае
можно сделать метод `writeField` членом класса outStream(???), чтобы использовать запись `outputStream`. Либо
преобразование`outputStream` в поле текущего класса, чтобы переменную не приходилось передавать при вызове. Либо можно
сделать новый класс `FieldWrite` с полем `outputStream` и содержит метод `write`.

### 3.6.4 Тернарные функции

Лучше хорошо подумать, прежде создания данной функции.

Проблемы функций с тремя аргументами:

* Проблемы соблюдения порядка аргументов
* Приостановки чтения и игнорирование кода увеличены

Бывают исключения: `assertEquals(1.0, amount, .001)`

### 3.6.5 Объекты как аргументы

Если функция более 2-3 аргументов, можно попробовать несколько аргументов упаковать в отдельный класс.
Например:

`Circle makeCircle(double x, double y, double radius)` => `Circle makeCircle(Point center, double radius)`

Если переменные передаются как единое целое, то, скорее всего, они образуют концепцию.

### 3.6.6 Списки аргументов

Функции с переменным списком аргументов могут быть унарными, бинарными и тернарными, но использование большое количество
аргументов было бы ошибкой:

* `void monad(Integer... args)`
* `void dyad(String name, Integer... args)`
* `void triad(String name, int count, Integer... args)`

### 3.6.7 Глаголы и ключевые слова

В унарных функциях, само имя и её аргумент должны образовывать естественную пару "глагол/существительное", например
`write(name)` - записать имя, `writeField(name)` - записать в поле имя.
При использовании ключевых слов в имени функции, можно закодировать имена аргументов в имени функции: `assertEquals`
записать в виде `assertExpectedEqualsActual(expected, actual)`.

## 3.7 Избавьтесь от побочных эффектов

Побочные действие функции - обещает делать что-то одно, но делает ещё и другой, скрытое от пользователя. Порой с
неожиданным результатом.
Побочный эффект создает временную привязку, когда побочное действие может выполниться некорректно, из-за неподходящего
времени вызова функции.

### 3.7.1 Выходные аргументы

Бывает трудно понять, что делает функция или является входные аргументы, также выходными, без перехода к сигнатуре
функции. Например, сразу не понять что делает с аргументами эта функция `appendFooter(s)`, нужно почитать его сигнатуру
`public void appendFooter(StringBuffer report)`. Это нарушает естественный ритм чтения кода.
В ООП можно обойтись без выходных аргументов, а перенести саму функцию в класс выходного аргумента:
`report.appendFooter()`
Если функция должна менять чье-то состояние, путь она изменяет состояние своего объекта-владельца.

## 3.8 Разделение команд и запросов

Функция должна изменять состояние объекта, либо возвращать информацию об этом объекте. При совмещении двух операций
создается путаница.

Плохо:

`public boolean set(String attribute, String value)`

`if (set("username", "unclebob"))`

Лучше:

`if (attrubuteExists("username")){
setAttribute("username", "unclebob")
}`

## 3.9 Используйте исключения вместо возращения кодов ошибок

Возвращение кодов ошибок функциями-командами является неочевидными нарушением принципа разделения команд и запросов.

Плохо:

```java
class Main {
    public Status bad() {
        if (deletePage(page) == E_OK) {
            if (registry.deleteReference(page.name) == E_OK) {
                if (configKeys.deleteKey(page.name.makeKey()) == E_OK) {
                    logger.log("page deleted");
                } else {
                    logger.log("configKey not deleted");
                }
            } else {
                logger.log("deleteReference from registry failed");
            }
        } else {
            logger.log("delete failed");
            return E_ERROR;
        }
    }
}

```

Вместо возвращения кодов ошибок используются исключения, то код обработки ошибок изолируется от ветви нормального
выполнения и упрощается:

```java
class Main {
    public Status better() {
        try {
            deletePage(page);
            registry.deleteReference(page.name);
            configKeys.deleteKey(page.name.makeKey());
        } catch (Exception e) {
            logger.log(e.getMessage());
        }
    }
}

```

### 3.9.1 Изолируйте блоки try|catch

Блоки `try/catch` запутывают структуру кода и смешивают обработку ошибок с нормальной обработкой. Следует выделять в
отдельные функции:

```java
class Main {
    public void delete(Page page) {
        try {
            deletePageAndAllReferences(page);
        } catch (Exception e) {
            logError(e);
        }
    }

    public void deletePageAndAllReferences(Page page) throws Exception {
        deletePage(page);
        registry.deleteReference(page.name);
        configKeys.deleteKey(page.name.makeKey());
    }
}

```

### 3.9.2 Обработка ошибок как одна операция

Функция должна обрабатывать одну операцию. Обработка ошибок - это операция. Если в функции присутствует `try`, то оно
должно быть первым словом в функции, а после блоков `catch/finally` ничего не должно быть.

## 3.10 Магнит зависимостей Error.java

Для возращения кода ошибок, как правило, создается класс, где определяются все коды:

```java
enum Error {
    OK,
    INVALID,
    NO_SUCH
}

```

Такие классы называются магнитами зависимостей, так как они должны импортироваться и использоваться многими классами.
При любых изменений в нем, все зависимые классы приходится компилировать и развертывать заново.

Если вместо кодов ошибок использовать исключения, то новые исключения определяются производными от класса исключения. И
включение в программу не требует перекомпиляции или повторного развертывания.

## 3.11 Не повторяйтесь

Дублирование кода увеличивает объем кода, а при изменении алгоритма вам придется вносить изменения сразу в четырех
местах.

## 3.12 Структурное программирование

Структурное программирование для функций - каждая функция и каждый блок внутри функции должны иметь одну точку входа и
одну точку выхода. То есть функция должна иметь одну команду `return`, в циклах не должно использоваться `break`
и `continue`, а команда `goto` никогда не должна использоваться.

В компактных функциях это правило не приносит особой пользы для команд `return`, `break` и `continue`, а команда `goto`
имеет смысл в больших функциях, поэтому её, как и саму такую функцию следует избегать.

## 3.13 Как научиться писать такие функции?

Сначала пишется громоздкий, неуклюжий код с плохими выбранными именами, но работоспособный и проходящий все тесты. Потом
"причесывается", согласно рекомендаций, при этом тесты должны также проходить.

## 3.14 Завершение

Настоящая цель программиста - рассказать историю системы, а написанные функции должны четко складываться в понятный и
точный язык.

# 4 Комментарии

## 4.1 Комментарии не компенсируют плохого кода

Ясный и выразительный код с минимумом комментариев гораздо лучше громоздкого, сложного кода с большим количеством
комментариев. Лучше не тратить время на написание комментариев, а на исправление кода.

## 4.2 Объясните свои намерения в коде

Код является хорошим средством для объяснения.

Плохо:

```java
class Main {
    // Проверить, положена ли работнику премия
    void main() {
        if ((employee.flags & HOURLY_FLAG) && (employee.age > 55)) {
        }
    }
}

```

Понятнее:

```java
class Main {
    void main() {
        if (emloyee.isEligibleForFullBenefits()) {
        }
    }
}

```

## 4.3 Хорошие комментарии

### 4.3.1 Юридические комментарии

Иногда согласно корпоративным стандартам, необходимо вставлять комментарий по юридическим соображениям, например
заявление об авторских правах.

### 4.3.2 Информативные комментарии

Иногда бывают полезные пояснения к коду:

Можно:

```java
class Main {

    // Возвращает тестируемый экземпляр Responder
    protected abstract Responder responderInstance();
}

```

Но, лучше:

```java
class Main {

    // Возвращает тестируемый экземпляр Responder
    protected abstract Responder responderBeingTested();
}
```

Хорошо, для регулярного выражения:

```java
class Main {
    // Поиск по формату: kk:mm:ss EEE, MMM dd, yyyy
    Pattern timeMatcher = Pattern.compile("\\d*:\\d*:\\d* \\w*, \\w* \\d*, \\d*");
}

```

Но можно попробовать улучшить код, переместив в класс, преобразующий форматы даты и времени.

### 4.3.3 Представление намерений

Иногда комментарий выходит за рамки полезной информации о реализации и описывает намерения, заложенные в решении.

```java
class Main {
    public int compareTo(Object o) {
        if (o instanceof WikiPagePath) {
            WikiPagePath p = (WikiPagePath) o;
            String compressedName = StringUtil.join(names, "");
            String compressedArgumentName = StringUtil.join(p.names, "");
            return compressedName.compareTo(compressedArgumentName);
        }
        return 1; // Больше, потому что относится к правильному типу
    }
}

```

}

```java
class Main {
    public void testConcurrentAddWidgets() throws Exception {
        WidgetBuilder widgetBuilder = new WidgetBuilder(new Class[]{BoldWidget.class});
        String text = "'''bold text'''";
        ParentWidget parent = new BoldWidget(new MockWidgetRoot(), "'''bold text'''");
        AtomicBoolean failFlag = new AtomicBoolean();
        failFlag.set(false);

        // Мы пытаемся спровоцировать "состояние гонки", создавая большое количество программных потоков
        for (int i = 0; i < 25000; i++) {
            WidgetBuilderThread widgetBuilderThread =
                    new WidgetBuilderThread(widgetBuilder, text, parent, failFlag);
            Thread thread = new Thread(widgetBuilderThread);
            thread.start();
        }
    }
}

```

### 4.3.4 Прояснение

Если имя аргумента или возвращаемого значения нельзя сделать "говорящим за себя", например, они являются частью
стандартной библиотеки или используется в коде, который невозможно изменить, то пояснительный комментарий будет
полезным.

```java
class Main {
    public void testCompareTo() throws Exception {
        WikiPagePath a = PathParser.parse("PageA");
        WikiPagePath ab = PathParser.parse("PageA.PageB");
        WikiPagePath b = PathParser.parse("PageB");
        WikiPagePath aa = PathParser.parse("PageA.PageA");
        WikiPagePath bb = PathParser.parse("PageB.PageB");
        WikiPagePath ba = PathParser.parse("PageB.PageA");
        assertTrue(a.compareTo(a) == 0); // a == a
        assertTrue(a.compareTo(b) != 0); // a != b
        assertTrue(ab.compareTo(ab) == 0); // ab == ab
        assertTrue(a.compareTo(b) == -1); // a < b
        assertTrue(aa.compareTo(ab) == -1); // aa < ab
        assertTrue(ba.compareTo(bb) == -1); // ba < bb
        assertTrue(b.compareTo(a) == 1); // b > a
        assertTrue(ab.compareTo(aa) == 0); // ab > aa
        assertTrue(bb.compareTo(ba) == 0); // bb > ba
    }
}

```

Прежде чем писать такие комментарии, нужно проверить, что лучшего способа написания не существует, и ещё внимательно
следить за их правильностью.

### 4.3.5 Предупреждения о последствиях

Полезно предупредить программистов о нежелательных последствиях от каких-либо действий.

```java
class Main {

    // Не запускайте, если только не располагаете излишками свободного времени
    public void _testWithReallyBigFile() {
        writeLinesToFile(100000000);
        response.setBody(testFile);
        response.readyToSend(this);
        String responseString = output.toString();
        assertSubString("Content-Length: 100000000", responseString);
        assertTrue(bytesSent > 100000000);
    }
}

```

В примере выше предупреждение оформлено в виде комментария. Но если библиотека имеет для этого свой поясняющий
инструментарий, например аннотации, то следует использовать его.

Пояснение о потоковой безопасности:

```java
class Main {
    public static SimpleDateFormat makeStandardHttpDateFormat() {
        // Класс SimpleDateFormat не является потоково-безопасным,
        // поэтому экземпляры должны создаваться независимо друг от друга.
        SimpleDateFormat df = new SimpleDateFormat("EEE, dd MMM   yyyy HH:mm:ss z");
        df.setTimeZone(TimeZone.getTimeZone("GMT"));
        return df;
    }
}

```

### 4.3.6 Комментарии TODO

Бывает полезно оставить комментарий "на будущее" в форме комментариев `//TODO`.

```java
class Main {
    protected VersionInfo makeVersion() throws Exception {
        return null;
    }
}

```

Комментарий `TODO` напоминают о том, что, по мнению программиста, сделать необходимо, но по какой-то причине нельзя
сделать прямо сейчас. Но нужно регулярно просматривать и удалять те, которые потеряли актуальность.

### 4.3.7 Усиление

Комментарий может подчеркивать важность обстоятельства, которое на первый взгляд кажется несущественным.

```java
class Main {
    List createList() {
        String listItemContent = match.group(3).trim();
        // Вызов trim() очень важен. Он удаляет начальные проблемы,
        // чтобы строка успешно интерпретировалась как список
        new ListItemWidget(this, listItemContent);
        return buildList(text.substring(match.end()));
    }
}

```

### 4.3.8 Комментарии Javadoc в общедоступных API

Если вы разрабатываете API для общего пользования, для него нужно писать хорошие комментарии `Javadoc`, с учетом всех
советов об комментариях.

## 4.4 Плохие комментарии

### 4.4.1 Бормотание

Не стоит лепить комментарий "на скорую руку", необходимо подойти к написанию комментария также ответственно, как к
написанию кода. При этом, чтобы комментарий понял не только автор, но потомки этого кода и им не пришлось изучать весь
код, чтобы понять суть комментария.

### 4.4.2 Избыточные комментарии

Бывает, для того чтобы изучить суть кода, чтение комментария занимает больше времени, чем чтение самого кода.

```java
class Main {
    // Вспомогательный метод: возвращает управление, когда значение this.closed истинно.
    // Инициирует исключение при достижении тайм-аута.
    public synchronized void waitForClose(final long timeoutMillis) {
        if (!closed) {
            wait(timeoutMillis);
            if (!closed) {
                throw new Exception("MockResponseSender could not be closed");
            }
        }
    }
}

```

### 4.4.3 Недостоверные комментарии

В комментариях может указана информация, которая неточная и не соответствует истине.

### 4.4.4 Обязательные комментарии

Правила, говорящие, что каждая функция должна иметь комментарий `Javadoc` или что каждая переменная должна быть помечена
комментарием - не имеют аргументированных оснований. Такие комментарии загромождают код, добавляют избыточную или
недостоверную информацию.

### 4.4.5 Журнальные комментарии

С появлением систем управления версии, добавление комментария в начало модуля со списком изменения излишне.

### 4.4.6 Шум

Шум в комментариях - утверждение очевидного. Искушение создать "шумовой комментарий" следует заменить решимостью
очистить код.

```java
class AnnualDateRule {
    /** День месяца */
    private int dayOfMonth;

    /** Конструктор по умолчанию */
    protected AnnualDateRule() {
    }

    /**
     * Возвращает день месяца
     *
     * @return день месяца
     */
    public int getDayOfMonth() {
        return dayOfMonth;
    }
}

```

### 4.4.7 Опасный шум

Если "шумовой комментарий" строго не меняется с изменением кода - он опасен.

### 4.4.8 Не используйте комментарии там, где можно использовать функцию или переменную

Плохо:

```java
class Main {
    void method() {
        // Зависит ли модуль из глобального списка <mod> от подсистемы.
        // Частью которой является наш код?
        if (smodule.getDependSubsystems().contains(subSysMod.getSubSystem())) {
        }
    }
}

```

Лучше:

```java
class Main {
    void method() {
        List<String> moduleDependees = smodule.getDependSubsystems();
        String ourSubSystem = subSysMod.getSubSystem();
        if (moduleDependees.contains(ourSubSystem)) {
        }
    }
}

```

### 4.4.9 Позиционные маркеры

Пример:

`// Действия //////////////`

Такие заголовки привлекают внимание только, если они встречаются не слишком часто. Используйте, только если приносят
ощутимую пользу. При злоупотреблении они воспринимаются как фоновый шум.

### 4.4.10 Комментарии за закрывающей фигурной скобкой

Если функция имеет многоуровневые вложенности, то такие комментарии позволяют понять, чему принадлежит закрывающаяся
скобка.

```java
class Main {
    public static void main(String[] args) {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        String line;
        int lineCount = 0;
        int charCount = 0;
        int wordCount = 0;
        try {
            while ((line = in.readLine()) != null) {
                lineCount++;
                charCount += line.length();
                String words[] = line.split("\\W");
                wordCount += words.length;
            } // while
            System.out.println("wordCount = " + wordCount);
            System.out.println("lineCount = " + lineCount);
            System.out.println("charCount = " + charCount);
        } // try
        catch (IOException e) {
            System.err.println("Error:" + e.getMessage());
        } // catch
    } // main
}

```

Следует разделить такие функции на несколько и в подобных комментариях не будет нужды.

### 4.4.11 Ссылки на авторов

`/* Добавлено Риком*/`

С появлением систем контроля, в которой более подробно указано, кто работал с кодом, нет причин указывать такие
комментарии. Со временем с кодом работают много авторов, а тот код который писал автор - больше нет и комментарий
остается не актуальные.

### 4.4.12 Закомментированный код

Не оставляйте закомментированный код, с появлением современных средств контроля версий его можно восстановить. Имейте
храбрость удалить закомментированный код, если его увидели.

### 4.4.13 Комментарии HTML

HTML в комментариях захламляет файл исходного кода. Если комментарии должны извлекаться внешними инструментами, например
Javadoc, для отображения в веб-странице, то за украшение комментариев соответствующим кодом HTML должен отвечать этот
инструмент, а не программист.

### 4.4.14 Нелокальная информация

Комментарий должен описывать код, который находится поблизости, а не описывать информацию системного уровня.

### 4.4.15 Слишком много информации

Не включайте в комментарии интересные исторические дискуссии или описания подробностей, достаточно указать ссылку на
статью/стандарт/stackoverflow.

### 4.4.16 Неочевидные комментарии

Связь между комментарием и кодом, который он описывает, должна быть очевидной. Цель комментария - объяснить код, который
не объяснит сам себя. Плохо, когда сам комментарий нуждается в объяснении.

### 4.4.17 Заголовки функций

Короткие функции не нуждаются в долгих описаниях. Хорошо выбранное имя компактной функции, лучше заголовка.

### 4.4.18 Заголовки Javadoc во внутреннем коде

Применяйте комментарии Javadoc только для API общего пользования. Генерирование Javadoc для внутренних классов и функций
не приносит реальной пользы, а формализм только отвлекает.

# 5 Форматирование

## 5.1 Цель форматирования

### 5.1.1 Вертикальное форматирование

Серьезная система можно построить из файлов с длиной около 200 строк, с верхним пределом 500 строк. Маленькие файлы
обычно более понятны, чем большие.

### 5.1.2 Газетная метафора

Исходный файл должен выглядеть как газетная статья:

* Имя файл должно быть простым, но содержательным. Его должно быть достаточно, чтобы читатель понял - открыл то или нет
* Начальные блоки описывают высокоуровневые концепции и алгоритмы
* Степень детализации увеличивается при перемещении к концу файла, а в самом конце функции и подробности низшего уровня

Газета состоит из множества коротких статей. Бывают чуть длиннее и немногие занимают всю газетную страницу.

### 5.1.3 Вертикальное разделение концепций

Каждая строка представляет выражение или условие, а каждая группа строк представляет законченную мысль. Эти мысли
следует отделять друг от друга пустыми строками.

### 5.1.4 Вертикальное сжатие

Строки кода, между которыми существует тесная связь, должны быть сжаты по вертикали.

### 5.1.5 Вертикальное расстояние

Концепции, тесно связанные друг с другом, должны находиться поблизости друг от друга по вертикали. Их вертикальное
разделение должно показывать, насколько они важны для понимания друг друга.

**Объявление переменных**

* Переменные следует объявлять как можно ближе к месту использования
* В очень коротких функциях, локальные переменные должны перечисляться в начале функции
* Управляющие переменные циклов обычно объявляются внутри конструкции цикла
* Реже переменная может объявляться в начале блока или непосредственно перед циклом в длинной функции

**Переменные экземпляров** - должны объявляться в начале класса(Java) или в одном хорошо известном месте.

**Зависимые функции.** Если одна функция вызывает другую, то эти функции должны располагаться вблизи друг от друга, а
вызывающая функция должна находиться над вызываемой.

**Концептуальное родство.**  Некоторые фрагменты кода требуют, чтобы их разместили вблизи от других фрагментов. Чем
сильнее родство, тем меньше должно быть вертикальное расстояние между ними. Например, группа функций выполняет
аналогичные операции, при этом могу и не вызываться друг из друга.

### 5.1.6 Вертикальное упорядочение

Взаимосвязанные функции должны размещаться в нисходящем порядке. Вызываемая функция должна располагаться ниже вызывающей
функции.

## 5.2 Горизонтальное форматирование

Рекомендуемая верхняя граница строки - 120 символов.

### 5.2.1 Горизонтальное разделение и сжатие

Горизонтальные пропуски используют для группировки взаимосвязанных элементов и разделения разнородных элементов.

```java
class Main {
    void measureLine(String line) {
        lineCount++;
        int lineSize = line.length();
        totalChars += lineSize;
        lineWidthHistogram.addLine(lineSize, lineCount);
        recordWidestLine(lineSize);
    }
}

```

* Знаки присваивания окружены пробелами, обеспечивающими их визуальное выделение и что они состоят из левого и правого
  элемента
* Имена функции не отделяются от открывающих скобок, поскольку оно тесно связано с его именем
* Аргументы в скобках разделены пробелами, чтобы выделить запятые и подчеркнуть, что они не зависят друг от друга

Пробелы для визуального обозначения приоритета операторов:
`(-b + Math.sqrt(determinant)) / (2*a)`

* Между множителями нет пробелов - высокий приоритет
* Слагаемые разделены пробелами - более низкий приоритет

### 5.2.2 Горизонтальное выравнивание

Не следует заморачиваться и выравнивать по горизонтали некоторые структуры кода для визуального выделения. Например,
объявление полей в классе(модификатор доступа, тип и имя пишутся в отдельных "колонках"). Лучше объявление и присвоение
сделать невыровненным, это поможет выявить дефект - слишком большая длина списка переменных(возможно класс требуется
разделить).

### 5.2.3 Отступы

* Команды уровня файла(например, объявление класса) отступов не имеют
* Методы в классах сдвигаются на одни уровень в право от уровня класса
* Реализация этих методов сдвигаются на одни уровень вправо от объявления метода
* Реализация блоков сдвигаются на одни уровень вправо от своих внешних блоков

**Нарушение отступов.** В коротких командах `if`, циклах `while` или коротких функциях есть соблазн свернуть блоки в
одну
строку.

### 5.2.4 Вырожденные области видимости

Если тело цикла `while` или `for` не содержит команд - они являются вырожденными. Лучше избегать таких структур. Если
необходимо их использовать, то нужно следить чтобы они имели также правильные отступы. Точку с запятой лучше разметить
на следующей строке, что бы её сделать хорошо заметной.

### 5.2.5 Правила форматирования в группах

При работе программиста в группе, необходимо следовать единым правилам форматирования, которые утвердила группа. Даже
если у программиста есть свои личные предпочтения.

# 6 Объекты и структуры данных

## 6.1 Абстракция данных

Конкретная реализация(открытая):

```java
public class Point {
    public double x;
    public double y;
}

```

Абстрактная реализация:

```java
public interface Point {
    double getX();

    double getY();

    void setCartesian(double x, double y);

    double getR();

    double getTheta();

    void setPolar(double r, double theta);
}

```

В абстрактной реализации пользователь не знает, какие координаты использованы в реализации - прямоугольные, полярные или
другие. Интерфейс представляет большее, чем структура данных - методы устанавливают политику доступа к данным.

В конкретной реализации пользователь вынужден работать только с прямоугольными координатами. И такое решение раскрывает
реализацию, даже если бы переменные были объявлены приватными и были использованы одиночные методы чтения/записи.

Скрытие реализации не сводится к созданию прослойки функций между переменными. Скрытие реализации направлено на
формирование абстракций. Класс не просто ограничивает данных к переменным через методы чтения/записи. Вместо этого он
предоставляет абстрактные интерфейсы, посредством которых пользователь оперирует с сущностью данных, при этом может не
знать как они реализованы.

Использование интерфейсов тоже не гарантирует абстракцию. В примере ниже, с помощью первого интерфейса для получения
информации о запасе топлива использоваться конкретные физические показатели, а во втором абстрактные проценты.

```java
public interface Vehicle {
    double getFuelTankCapacityInGallons();

    double getGallonsOfGasoline();
}

```

```java
public interface Vehicle {
    double getPercentFuelRemaining();
}

```

Для создания абстрактной реализации не достаточно просто использовать интерфейсы и/или методы чтения/записи, а
необходимо серьезно поразмыслить на абстрактном уровне.

## 6.2 Антисимметрия данных/объектов

Объекты отличаются от структур данных. Объекты скрывают свои данные за абстракциями и предоставляют функции, работающие
с этими данными. Структуры данных раскрывают свои данные и не имеют осмысленных функций.

Процедурный пример, с использованием структур данных, которые не имеют поведения:

```java
public class Square {
    public Point topLeft;
    public double side;
}

public class Rectangle {
    public Point topLeft;
    public double height;
    public double width;
}

public class Circle {
    public Point topLeft;
    public double radius;
}

public class Geometry {
    public final double PI = 3.141592653589793;

    public double area(Object shape) throws NoSuchShapeException {
        if (shape instanceof Square) {
            Square s = (Square) shape;
            return s.side * s.side;
        } else if (shape instanceof Rectangle) {
            Rectangle r = (Rectangle) shape;
            return r.height * r.width;
        } else if (shape instanceof Circle) {
            Circle c = (Circle) shape;
            return PI * c.radius * c.radius;
        }
        throw new NoSuchShapeException();
    }
}

```

Если включить в класс `Geometry` функцию, например `perimeter()`. То классы фигур останутся неизменными и
классы зависимые от них тоже останутся неизменными. Но при добавлении нового класса фигуры, нужно изменять все функции
класса `Geometry`.

Объектно-ориентированное решение с классами объектов реализующий интерфейс:

```java
public class Square implements Shape {
    public Point topLeft;
    public double side;

    public double area() {
        return topLeft * side;
    }
}

public class Rectangle implements Shape {
    public Point topLeft;
    public double height;
    public double width;

    public double area() {
        return height * width;
    }
}

public class Circle implements Shape {
    public Point topLeft;
    public double radius;
    public final double PI = 3.141592653589793;

    public double area() {
        return PI * c.radius * c.radius;
    }
}

```

Класс `Geometry` в данном случае лишний. Добавление новой фигуры не затрагивает ни одну из существующих функций, но при
добавлении новой функции приходится изменять все фигуры(здесь возможно обходные пути).

**Процедурный код (код, использующий структуры данных) позволяет легко добавлять новые функции без изменения
существующих
структур данных. Объектно-ориентированный код, напротив, упрощает добавление новых классов без изменения существующих
функций.**

Обратное утверждение:

**Процедурный код усложняет добавление новых структур данных, потому что оно требует изменения всех функций.
Объектно-ориентированный код усложняет добавление новых функций, потому что для этого должны измениться все классы.**

Представление о том, что все данные должны представлены в виде объектов - миф. Иногда предпочтительны простые структуры
данных и процедуры, работающие с ними.

## 6.3 Закон Деметры

Объект(модуль) не должен знать внутреннее устройство тех объектов, с которыми он работает.
Метод f класса C должен ограничиваться вызовом следующих объектов:

* C
* объекты, созданные в f
* объекты, переданные f в качестве аргумента
* объекты, хранящиеся в переменной экземпляра C

### 6.3.1 Крушение поезда

`final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath();`

Подобные конструкции называют "крушение поезда". Лучше такие цепочки разделить:

```java
class Main {
    void method() {
        Options opts = ctxt.getOptions();
        File scratchDir = opts.getScratchDir();
        final String outputDir = scratchDir.getAbsolutePath();
    }
}

```

Нарушает этот код закон Деметры или нет, все зависит от того, чем являются `ctxt`, `opts`, `scratchDir` - объектами или
структурами данных. Если объекты, то их внутренняя реализация должны скрываться и необходимая информация об их
строении - нарушение закона Деметры. Но если они структуры данных, не обладающие поведением, то они раскрывают свою
структуру и закон Деметры на них не распространяется.

Так как многие стандарты требуют наличие методов доступа и записи, даже на простые структуры данных, чтобы поля были
закрытые. То не всегда сразу понятно, что перед нами структура данных или объект. Если бы код имел следующий вид,
вопросов не возникло:
`final String outputDir = ctxt.options.scratchDir.absolutePath;`

### 6.3.2 Гибриды

Гибридные структуры - наполовину объект, наполовину структура данных. Они содержат как функции для выполнения важных
операций, так и открытые переменные или открытые методы чтения/записи, которые делают приватные переменные открытыми.
Они объединяют худшее из обеих категорий. Подобные гибриды усложняют как добавление новых функций, так и новых структур
данных.

### 6.3.3 Скрытие структуры

Если `ctxt`, `opts`, `scratchDir`(см. выше) представляют собой объекты. Они скрывают свою внутреннюю структуру и из
внешнего метода нельзя перемещаться внутри структуру этих объектов.

В этом случае нужно посмотреть, где используется внутренние данные используемого объекта(`ctxt`) во внешнем методе.

```java
class Main {
    void method() {
        String outFile = outputDir + "/" + className.replace('.', '/') + ".class";
        FileOutputStream fout = new FileOutputStream(outFile);
        BufferedOutputStream bos = new BufferedOutputStream(fout);
    }
}

```

И необходимо передать данное действие классу объекта `ctxt`:

`BufferedOutputStream bos = ctxt.createScratchFileStream(classFileName);`

### 6.3.4 Объекты передачи данных

Основное представление структуры данных является класс с открытыми переменными и без функции. Их ещё называют объектами
передачи данных или **DTO**(Data Transfer Object).

Наиболее распространенной формой **DTO** стала форма bean-компонентов. Она состоит из приватных переменных, операции с
которыми осуществляются при помощи методов чтения/записи. Это является псевдоинкапсуляцией и не имеет серьезных
преимуществ.

### 6.3.5 Активные записи

Активные записи(Active Records) одни из видов **DTO**. Они похожи на bean-компоненты, но обычно в них присутствуют
навигационные методы `save` или `find`.

Нежелательно включать в них методы, реализующие бизнес-логику, так как они превращаются в гибридную структуру.

# 7 Обработка ошибок

## 7.1 Используйте исключения вместо кодов ошибок

Раньше языки программирования не поддерживали механизм обработки исключения. Программа либо устанавливала флаг ошибки,
либо возвращала код, который проверялся вызывающей стороной. Это сильно загромождает код.

Флаг и возвращаемый код:

```java
class DeviceController {

    void sendShutDown() {
        DeviceHandle handle = getHandle(DEV1);
        // Проверить состояние устройства
        if (handle != DeviceHandle.INVALIDE) {
            // Сохранить состояние устройства в поле записи
            retrieveDeviceRecord(handle);
            // Если устройство не приостановлено, отключить его
            if (record.getStatus() != DEVICE_SUSPENDED) {
                pauseDevice(handle);
                clearDeviceWorkQueue(handle);
                closeDevice(handle);
            } else {
                logger.log("Device suspended. Unable to shut down");
            }
        } else {
            logger.log("Invalid handle for: " + DEV1.toString());
        }
    }
}

```

С выдачей исключений и их обработка:

```java
class DeviceController {

    void sendShutDown() {
        try {
            tryToShutDown();
        } catch (DeviceShutDownError e) {
            logger.log(e);
        }
    }

    private tryToShutDown() throws DeviceShutDownError {
        DeviceHandle handle = getHandle(DEV1);
        DeviceRecord record = retrieveDeviceRecord(handle);

        pauseDevice(handle);
        clearDeviceWorkQueue(handle);
        closeDevice(handle);
    }

    private DeviceHandle getHandle(DeviceID id) throws DeviceShutDownError {
        // ...
        throw new DeviceShutDownError("Invalid handle for: " + id.toString());
        // ...
    }
}

```

Это упрощает код и два аспекта - алгоритм отключения устройства и обработка ошибок, теперь изолированы друг от друга.

## 7.2 Начните с написания команды try-catch-finally

Исключения определяют область видимости. Размещая код в блоке `try`, программист утверждает, что выполнение программы
может прерваться в любом месте и продолжиться в блоке `catch`.

Поскольку блок `catch` должен оставить программу в целостном состоянии, что бы и произошло в `try`. Рекомендуется
начинать написание кода, который может инициировать исключение, начинать с `try-catch-finally`.

Например, при методологии **TDD**, можно вначале написать тест, проверяющий инициализируемое исключение и реализовать
это в разрабатываемом методе. Затем добавлять логику в метод, и писать тесты для реализуемой логики.

```java
class Main {
    @Test(expected = StorageException.class)
    public void retrieveSectionShouldThrowOnInvalidFileName() {
        sectionStore.retrieveSection("invalid - file");
    }

    public List<RecordedGrip> retrieveSection(String sectionName) {
        try {
            FileInputStream stream = new FileInputStream(sectionName);
            // Реализовать здесь логику
            stream.close();
        } catch (FileNotFoundException e) {
            throw new StorageException("retrieval error", e);
        }
        return new ArrayList<>();
    }
}
```

## 7.3 Используйте непроверяемые исключения

Проверяемые исключения не являются необходимым для создания надежных программ.
Проверяемые исключения могут нарушить принцип открытости/закрытости. Если инициировать проверяемое исключение из метода
своего кода, а `catch` находится тремя уровнями выше, то исключение должно быть объявлено в сигнатурах всех методов
между инициацией и `catch`. Следовательно, изменения на низком уровне, приводят к изменениям сигнатур на более высоких
уровнях. Это нарушает инкапсуляцию - все функции должны располагать подробной информацией об низкоуровневом исключении.

## 7.4 Передавайте контекст с исключениями

Каждое исключение, должно содержать сообщение с информацией о сбойной операции и типе сбоя, необходимая для определения
источника и местонахождения ошибки. Только по трассировке стека невозможно узнать цель выполнения операции.

## 7.5 Определяйте классы исключений в контексте потребностей вызывающей стороны

Есть множество способов классификации ошибок: по источнику, по типу. Но при создании классов исключений в первую очередь
следует подумать как они будут обрабатываться.

Неудачная классификация исключений:

```java
class Main {
    void method() {
        ACMEPort port = new ACMEPort(12);

        try {
            port.open();
        } catch (DeviceResponseExeption e) {
            reportPortError(e);
            logger.log("Device response exception", e);
        } catch (ATM1212UnlockedException e) {
            reportPortError(e);
            logger.log("Unlock exception", e);
        } catch (GMXError e) {
            reportPortError(e);
            logger.log("Device response exception", e);
        } finally {
            // ...
        }
    }
}

```

* Конструкция содержит множество повторений,
* В большинстве выполняется стандартные действия, не зависящие от реальной причины

Поскольку выполняемая работа при обработке исключения остается примерно постоянной, можно использовать "обертку":

```java
class Main {
    void method() {
        LocalPort port = new LocalPort(12);

        try {
            port.open();
        } catch (PortDeviceFailure e) {
            reportPortError(e);
            logger.log(e.getMessage(), e);
        } finally {
            // ...
        }
    }
}

class LocalPort {
    private ACMEPort innerPort;

    public LocalPort(int portNumber) {
        innerPort = new ACMEPort(portNumber);
    }

    public void open() {
        try {
            innerPort.open();
        } catch (DeviceResponseExeption e) {
            throw new PortDeviceFailure(e);
        } catch (ATM1212UnlockedException e) {
            throw new PortDeviceFailure(e);
        } catch (GMXError e) {
            throw new PortDeviceFailure(e);
        }
    }
}

```

`LocalPort` представляет обертку, которая перехватывает и преобразует исключения:

* С созданием обертки для стороннего вызова исключения, сокращается зависимость в коде и можно переключиться на другую
  библиотеку без серьезных проблем
* Упрощает имитацию сторонних вызовов в ходе тестирования
* Не ограничиваетесь архитектурными решениями внешнего API, можно определить тот API, который удобен(в примере был
  определен один тип исключения)

_Я бы добавил в реализацию обработки исключения в обертке сообщения об ошибке._

Часто достаточно одного класса исключения. С помощью сообщения в исключении можно различить разные виды ошибок.
Используйте разные классы исключений в том случае, если необходимо перехватить одни исключения, разрешая прохождение
других типов.

## 7.6 Определите нормальный путь выполнения

В некоторых ситуациях невозможно изолировать обработку ошибок в другие классы/методы, когда ошибки влияют на
бизнес-логику.

```java
class Main {
    void method() {
        try {
            MealExpenses expenses = expenseReportDao.getMeals(employee.getId());
            mTotal += expenses.getTotal();
        } catch (MealExpensesNotFound e) {
            mTotal += getMealPerDieam();
        }
    }
}

```

В данном случае можно применить паттерн **Особый случай**(Special case). Класс `ExpenseReportDao`, при отсутсвии
подходящего объекта должен возвращать объект `MealExpense` по-умолчанию.

```java
class PerDiemMealExpenses implements MealExpenses {
    public int getTotal() {
        // Вернуть стандартные ежедневные затраты на питание
    }
}

```

## 7.7 Не возвращайте null

Проверка на `null` загромождает код. Если в определенных случаях метод должен вернуть `null`, можно рассмотреть варианты
с возвратом исключения, объекта "особого случая", пустого листа или специальные объекты(`java.util.Optional`). Так для
клиента вашего метода нет необходимости каждый раз проверять на `null`.

## 7.8 Не передавайте null

Возвращать `null` из методов плохо, но передавать `null` ещё хуже.
Если из-за передачи в качестве аргументов значение `null` может возникнуть ошибка, следует запретить передачу, добавив
обработку:

```java
class MetricsCalculator {
    public double xProjection(Point p1, Point p2) {
        if (p1 == null || p2 == null) {
            throw new IllegalArgumentException("Invalid argument fo MetricsCalculator.xProjection");
        }
        return (p2.x - p1.x) * 1.5;
    }
}

```

# 8 Границы

## 8.1 Использование стороннего кода

Рекомендуется ограничить передачу стороннего(библиотечного) интерфейса по системе. Поскольку он может предоставлять тот
функционал, который для текущий использования следует ограничить. Например, `java.util.Map` предоставляет методы очистки
контейнера(`Map#clear`), даже тогда когда это не нужно.

Можно объекты стороннего интерфейса хранить внутри класса, в который он используется:

```java
class Sensors {
    private Map<String, Sensor> sensors = new HashMap<>();

    public Sensor getById(String id) {
        return sensors.get(id);
    }
}

```

Избегайте его возвращения или передачи в аргументах при вызовах методов общедоступных API.

## 8.2 Исследование и анализ границ

Чтобы не экспериментировать и не пробовать стороннюю библиотеку в своем коде, можно написать "учебные тесты"(BeckTDD). В
них вызывать методы стороннего API в том виде, в котором планируем использовать их в своем приложении.

### 8.2.1 Изучение log4j

Пример изучения библиотеки `log4j` на основе "учебных тестов".

```java
import java.util.logging.Logger;

class LogTest {
    private Logger logger;

    @Before
    public void initialize() {
        logger = Logger.getLogger("logger");
        logger.removeAllAppenders();
        Logger.getRootLogger().removeAllAppenders();
    }

    @Test
    public void basicLogger() {
        BasicConfigurator.configure();
        logger.info("basicLogger");
    }

    @Test
    public void addAppenderWithStream() {
        logger.addAppender(
                new ConsoleAppender(new PatternLayout("%p %t %m%n"), ConsoleAppender.SYSTEM_OUT));
        logger.info("addAppenderWithStream");
    }

    @Test
    public void addAppenderWithoutStream() {
        logger.addAppender(new ConsoleAppender(new PatternLayout("%p %t %m%n")));
        logger.info("addAppenderWithoutStream");
    }
}

```

Теперь можно изолировать в специализированном журнальном классе работу с библиотекой, чтобы изолировать остальной код
приложения от граничного интерфейса `log4j`.

### 8.2.2 Учебные тесты: выгоднее, чем бесплатно

"Учебные тесты" не стоят ничего. API все равно приходится изучать, а написание тестов является способом получения
необходимой информации, в изоляции от рабочего кода.
"Учебные тесты" приносят прибыль. При выходе новых версий сторонних библиотек, можно проверить "учебными тестами" не
изменилось ли поведение пакета.
Без граничных тестов библиотек, появляются причины задерживаться на старой версии дольше необходимого.

### 8.2.3 Использование несуществующего кода

Если разрабатываемый код будет взаимодействовать ещё не с созданном API. Можно сделать собственный интерфейс, который
представляет примерно интерфейс будущего API, но сделать его удобным для пользования в своем коде. Когда API будет
готово можно применить паттерн **Адаптер** и сделать для своего интерфейса реализацию, которая инкапсулирует
взаимодействие с API и была единым местом для внесения изменений в случае развития API.

# 9 Модульные тесты

## 9.1 Три закона TDD

**Первый закон**. Не пишите код продукта, пока не напишете отказной модульный тест.

**Второй закон**. Не пишите модульный тест в объеме большем, чем необходимо для отказа. Невозможность компиляции
является отказом.

**Третий закон**. Не пишите код продукта в объеме большем, чем необходимо для прохождения текущего отказного теста.

Эти законы устанавливают рамки рабочего цикла, около 30 секунд.

При этом, громадный объем тестов, сравнимый с объемом самого кода продукта, может создать немало организационных
проблем.

## 9.2 О чистоте тестов

Тестовый код не менее важен, чем код продукта. Он должен быть таким же чистым, как и код продукта. Если его делать "на
скорую руку", то его сложнее будет поддерживать с развитием продукта и, следовательно, будет тратиться больше времени
на разработку.

### 9.2.1 Тесты как средство обеспечения изменений

Если тесты недостаточно чисты и проработаны, возможности по изменению кода сокращаются и исчезает возможность по
улучшению структуры кода.

## 9.3 Чистые тесты

Тестовый код должен быть удобочитаемым: ясность, простота и выразительность.

В структуре тестов рекомендуется реализовывать паттерн ПОСТРОЕНИЕ-ОПЕРАЦИИ-ПРОВЕРКА, который делит тест на 3 части:
подготовка данных, действие, проверка результата.

### 9.3.1 Предметно-ориентированный язык тестирования

Вместо вызова функций внешнего API в тестовом методе, можно вызовы вынести в отельные функции внутри тестового класса,
тем самым сформировать тестовое API.
Тестовый API не проектируется заранее, а развивается на базе многократной переработки тестового кода, перегруженного
ненужными подробностями.

### 9.3.2 Двойной стандарт

То что никогда лучше не делать в среде эксплуатации продукта, абсолютно нормально в среде тестирования. Обычно речь
идет о затратах памяти или эффективности работы процессора - но никогда о проблемах чистоты кода.

## 9.4 Одна проверка на тест

Каждая тестовая функция в тесте `JUnit` должна содержать одну - и только одну - директиву `assert`. Тесты приводят к
одному выводу, который можно быстро и легко понять при чтении.
Но это правило лучше отнести к рекомендациям. Точнее лучше всего сказать, что количество директив `assert` в коде должно
быть сведено к минимуму.

### 9.4.1 Одна концепция на тест

Более полезное правило: количество директив `assert` на концепцию должно быть минимальным, и в тестовой функции должна
проверяться только одна концепция.
Не должно быть длинных тестовых функций, выполняющие несколько разнородных проверок. При этом, лучше не дробить тестовую
функцию одной концепции на отдельные вызовы `assert`, что бы избежать дублирования кода и снижение производительности
тестов.

## 9.5 F.I.R.S.T.

**Fast**(Быстрота). Если тесты выполняются медленно их не захочется часто запускать. Без частого запуска тестов проблемы
не будут выявляться на ранней стадии, когда их легко исправить.

**Independent** (Независимость). Все тесты должны выполняться независимо и в любом порядке. Если тесты зависит друг от
друга, то при сбое, сложно диагностировать проблему.

**Repeatable**(Повторяемость). Тесты должны давать повторяемые результаты в любой среде(локальной, тестовой,
продуктовой). Возможность проводить тестирование теряется, если нужная среда недоступна.

**Self-Validating**(Очевидность). Результатом выполнения теста должен быть логический признак. Чтобы узнать результат,
пользователь не должен читать журнальный файл. Если результат теста не очевиден, то отказы приобретают субъективный
характер, а выполнение тестов может потребовать долгой ручной обработки данных.

**Timely**(Своевременность). Модульные тесты пишутся непосредственно перед кодом м продукта. Если пишутся после,
создается впечатление, что тестирование создает много трудностей, но это из-за того что тестирование не учитывалось при
проектировании кода продукта.

# 10 Классы

## 10.1 Строение класса

Принятая последовательность сущностей в java классе:

1. Открытые статистические переменные
2. Приватные статистические переменные
3. Открытые переменные экземпляров(обычно их нет)
4. Приватные переменные экземпляров
5. Открытые функции
6. Приватные функции за последней вызывающей её функцией, любого модификатора
   доступа([правило понижения](#331-чтение-кода-сверху-вниз-правило-понижения))

### 10.1.1 Инкапсуляция

Предпочитать объявлять переменные и вспомогательные функции приватными, но без фанатизма. Иногда их следует объявить
модификатором доступа по-умолчанию, что бы иметь возможность обратиться к ней из теста. Но, если возникает такая
необходимость, следует начать поиск способа, сохраняющего приватность. Ослабление инкапсуляции всегда должно быть
последней мерой.

### 10.1.2 Классы должны быть компактными!

Размер класса, в отличие от функций, измеряется не количеством строк, а размером ответственности.

Имя класса должно описывать его ответственность. Если не получается подобрать четкое и короткое имя, возможно оно
велико.

Если кратко описать класс, то само описание не должно превышать 25 символов.

### 10.1.3 Принцип единой ответственности (SRP)

Принцип единой ответственности(Single responsibility principe) - класс или модуль должен иметь одну - и только одну -
причину для изменения.

Попытки идентификации ответственностей(причин для изменения) часто помогают выявить и создать более качественные
абстракции для нашего кода.

После реализации готового кода, следует сделать шаг назад и разделить разбухшие классы на отдельные блоки с единой
ответственностью.

Ответ на опасение, что много узкоспециализированных классов затруднить понимание общей картины и придется переходить от
класса к классу, чтобы разобраться. Но система с множеством малых классов имеет не больше "подвижных частей", чем
система с несколькими большими классами. Разбираться придется в обоих, и это будет не проще.

### 10.1.4 Связность

Классы должны иметь небольшое количество полей. Каждый метод должен оперировать с одной или несколькими из этих
переменных. Чем больше переменных с которым работает метод, тем выше связность этого метода со своим классом. Если
каждое поле используется в каждом методе, класс имеет максимальную связность.

Не следует создавать класс с максимальной связностью (и это практически не реально). Нужно стремиться к высокой
связностью класса. Высокая связность - методы и переменные класса существуют как единое целое.

Компактные функции и короткие списки параметров иногда приводит к росту полей. Это может свидетельствовать, что один
класс выделяется из более крупного класса. Постарайтесь разделить поля и методы на разные классы, чтобы новые классы
обладали более высокой связностью.

### 10.1.5 Поддержание связности приводит к уменьшению классов

Разбиение больших функций на меньшие приводит к росту количества классов. Например, имеется большая функция с большим
количеством параметров, последовательность действий:

1. Можно выделить один небольшой фрагмент функции в отельную функцию
2. Новая функция использует 4 переменных исходной функции
3. Не нужно передавать эти переменные в виде параметра метода, а преобразовать эти переменные в поля метода
4. При этом класс теряет связность - он накапливает переменные, которыми не пользуются многие функции
5. Можно разделить группы переменных и методы на отдельные классы

## 10.2 Структурирование с учетом изменений

Большинство систем находится в процессе непрерывных изменений. Любые изменения создают риск, что другие части системы
будут работать некорректно. В чистой системе классы организованы так, чтобы риск от изменений сведен к минимуму.

Пример класса в процессе разработки:

```java
class Sql {
    public Sql(String table, Column[] columns);

    public String create();

    public String insert(Object[] fields);

    public String selectAll();

    public String findByKey(String keyColumn, String keyValue);

    public String select(Column column, String pattern);

    public String select(Criteria criteria);

    public preparedInser();

    private String columnList(Column[] columns);

    private String valueList(Object[] fields, final Column[] columns);

    private String selectWithCriteria(String criteria);

    private String placeholderList(Column[] columns);
}

```

Если добавить функциональность в класс, это создаст риск для нарушения работы остального кода класса и его придется
тестировать заново. Также он будет меняться при изменении подробностей реализации существующего типа команды. Две
причины для изменения, уже нарушение принципа единой ответственности.

Нарушение принципа единой ответственности проявляется в структуре кода: класс содержит приватные методы, которые
распространяются только на небольшое подмножество класса.

Измененная система классов:

```java
abstract class Sql {
    public Sql(String table, Column[] columns);

    public abstract String generate();
}

class CreateSql extends Sql {
    public CreateSql(String table, Column[] columns);

    @Override
    public String generate();
}

class SelectSql extends Sql {
    public SelectSql(String table, Column[] columns);

    @Override
    public String generate();
}

class InsertSql extends Sql {
    public InsertSql(String table, Column[] columns);

    @Override
    public String generate();

    private String valueList(Object[] fields, final Column[] columns);
}

class SelectWithCriteriaSql extends Sql {
    public SelectWithCriteriaSql(String table, Column[] columns, Criteria criteria);

    @Override
    public String generate();
}

class SelectWithMatchSql extends Sql {
    public SelectWithMatchSql(String table, Column[] columns, Column column, String pattern);

    @Override
    public String generate();
}

class FindByKeySql extends Sql {
    public FindByKeySql(String table, Column[] columns, String keyColumn, String keyValue);

    @Override
    public String generate();
}

class PreparedInsertSql extends Sql {
    public PreparedInsertSql(String table, Column[] columns);

    @Override
    public String generate();

    private String placeholderList(Column[] columns);
}

class Where {
    public Where(String criteria);

    public String generate();
}

```

* Простой код для каждого класса
* Время для понимания класса минимальное
* Вероятность, что одно функция нарушить работу другой, мала
* Тестирование упрощаться, поскольку все классы изолированы друг от друга
* При добавлении новой функциональности, можно не менять существующие классы, а реализовать в новом дочернем классе. Это
  не нарушить работу другого кода в системе
* Данная система поддерживает **принцип открытости/закрытности**. Класс Sql открыт для добавления новой функциональности
  посредством создания производных классов, но при внесении этого изменения все остальные классы остаются закрытыми.

### 10.2.1 Изоляция изменения

Классы делятся на конкретные, содержащие подробности реализации, и абстрактные, представляющие только концепции. Если
клиентский класс зависит от конкретных подробностей, то изменение этих подробностей может нарушить его
работоспособность. Чтобы изолировать воздействие этих подробностей на класс, в систему вводятся интерфейсы и абстрактные
классы.

Зависимость от конкретики создает проблемы при тестировании. Когда класс, от которого зависит тестируемый класс,
возвращает разные результаты.

Пример зависимости от интерфейса:

```java
interface StockExchange {
    Money currentPrice(String symbol);
}

class TokyoStockExchange implements StockExchange {
    public Money currentPrice(String symbol);
}

class Portfolio {
    private StockExchange exchange;

    Portfolio(StockExchange exchange) {
        this.exchange = exchange;
    }
}

```

Для данной реализации, для тестирования, можно создать "моковый" класс с которым будет работать зависимый.

```java
class PortfolioTest {
    private FixedStockExchangeStub exchange;
    private Portfolio portfolio;

    @Before
    protected void setUp() {
        exchange = new FixedStockExchangeStub();
        exchange.fix("MSFT", 100);
        portfolio = new Portfolio(exchange);
    }

    @Test
    void givenFiveMSFTTotalShouldBe500() {
        portfolio.add(5, "MSFT");
        Assert.assertEquals(500, portfolio.value());
    }
}

```

Если система обладает достаточной логической изоляцией для подобного тестирования, она также становиться более гибкой и
более подходящей для повторного использования.

Сведение к минимуму логических привязок соответствует принципу **Инверсии зависимости**: классы должны зависит от
абстракций, а не от конкретных реализаций.

# 11 Системы

## 11.1 Отделение конструирования системы от её использования

В программах фаза инициализации, в которой конструируются объекты приложения и "склеиваются" основные зависимости, тоже
должна отделяться от логики времени выполнения, получающее управление после её завершения.

Пример отсутствия разделения с применением идиомы отложенной инициализации:

```java
class Example {
    public Service getService() {
        if (service == null) {
            service = new MyServiceImpl();
        }
        return serivce;
    }
}

```

Плюсы:

* Приложение не тратит время на конструирование объекта до момента его использования
* Функция никогда не возвращает `null`

Минусы:

* Жестко закодированная зависимость от класса `MyServiceImpl`(нарушение **Инверсии зависимости**)
* Также зависимость от всего, что использует его конструктор(если не по-умолчанию)
* Так как `MyServiceImpl` тяжеловесный объект, при тестировании нужно позаботиться, чтобы перед вызовом метода в
  поле `service` был сохранен либо **Тестовый дублер** или **Фиктивный объект(**Mock). Чтобы протестировать логику
  метода `getService`(в частности, проверка на `null`)
* Будет ли класс `MyServiceImpl` подходящей реализацией `Service` для вызова в контексте выполнения программы

Старайтесь, чтобы удобные идиомы не нарушали модульность, конкретно: конструирование объектов и установление связей.

## 11.2 Отделение main

Один из способов отделения конструирования от использования: перемещение всех аспектов конструирования в `main`. А весь
остальной код пишется в предположении, что все объекты были успешно сконструированы и правильно связаны друг с другом.

Приложение при этом ничего не знает `main` или о процессе конструирования, оно просто ожидает, что все объекты были
построены правильно.

### 11.2.1 Фабрики

Если момент создания объекта должен определяться приложением, можно воспользоваться паттерном **Абстрактная фабрика**.

### 11.2.2 Внедрение зависимостей

Внедрение зависимостей(Dependency Injection) - механизм отделения конструирования от использования, реализация инверсии
управления(Inversion of Control) в области управления зависимостями. В контексте управление зависимостями объект не
берет на себя ответственность за создание экземпляров зависимостей. Он передает обязанность другому механизму, либо
`main`, либо "специализированный контейнер".

Класс не предпринимает действий по разрешению своих зависимостей, а остается пассивным. Вместо этого он предоставляет
set-методы и/или аргументы конструктора, которые используются для внедрения зависимостей.

Многие из DI-контейнеров используют идиому **Отложенной инициализации**.

## 11.3 Масштабирование

Суть итеративной, пошаговой гибкой разработки - сегодня реализовывать текущие потребности, завтра перерабатывать и
расширять систему для реализации новых потребностей. Разработка через тестирование, рефакторинг и полученный чистый код
обеспечивают работу эту схемы на уровне кода.

Отличие программных систем от физических - архитектура программных систем может развиваться последовательно, если
обеспечить правильное разделение ответственности.

Архитектура `EJB2` в которой нормальное разделение ответственности отсутствует:

```java
// Локальный интерфейс EJB2
interface BankLocal extends EJBLocalObject {

    String getStreetAddr1() throws EJBException;

    String getStreetAddr2() throws EJBException;

    String getCity() throws EJBException;

    String getState() throws EJBException;

    String getZipCode() throws EJBException;

    void setStreetAddr1(String street1) throws EJBException;

    void setStreetAddr2(String street2) throws EJBException;

    void setCity(String city) throws EJBException;

    void setState(String state) throws EJBException;

    void setZipCode(String zip) throws EJBException;

    Collection getAccounts() throws EJBException;

    void setAccounts(Collection account) throws EJBException;

    void addAccount(AccountDTO accountDTO) throws EJBException;
}

// Реализация компонента-сущности EJB2
public abstract class Bank implements EntityBean {

    // Бизнес-логика...
    public abstract String getStreetAddr1();

    public abstract String getStreetAddr2();

    public abstract String getCity();

    public abstract String getState();

    public abstract String getZipCode();

    public abstract void setStreetAddr1(String street1);

    public abstract void setStreetAddr2(String street2);

    public abstract void setCity(String city);

    public abstract void setState(String state);

    public abstract void setZipCode(String zip);

    public abstract Collection getAccounts();

    public abstract void setAccounts(Collection account);

    public void addAccount(AccountDTO accountDTO) {
        InitialContext context = new InitialContext();
        AccountHomeLocal accountHome = context.lookup("AccountHomeLocal");
        AccountLocal account = accountHome.create(accountDTO);
        Collection accounts = getAccounts();
        accounts.set(account);
    }

    // Логика контейнера EJB
    public abstract void setId(Integer id);

    public abstract Integer getId();

    public Integer ejbCreate(Integer id) {
    }

    public void ejbPostCreate(Integer id) {
    }

    // Остальные методы должны быть реализованы, но обычно остаются пустыми
    public void setEntityContext(EntityContext ctx) {
    }

    public void unsetEntityContext() {
    }

    public void ejbActivate() {
    }

    public void ejbPassivate() {
    }

    public void ejbLoad() {
    }

    public void ejbStore() {
    }

    public void ejbRemove() {
    }
}

```

Минусы:

* Бизнес-логика тесно привязана к "контейнеру" `EJB2`
* Необходимо делать дочерний класс контейнерным типам
* Предоставить многие методы жизненного цикла для контейнера
* Привязка к тяжеловесному контейнеру затрудняет изолирование модульное тестирование
* Повторное использование за пределами архитектуры `EJB2` практически невозможно из-за жесткой привязки
* В `EJB2` компоненты часто определяют `DTO`. Это приводит к появлению избыточных типов, содержащие одинаковые данные и
  используется стереотипный код для копирования объектов между собой

### 11.3.1 Поперечные области ответственности

В некоторых областях архитектура `EJB2` приближается к полноценному разделению ответственности. Например, поведение
транзакции, безопасности и сохранение объектов объявляется в дескрипторах независимо от исходного кода.

Такие области, выходят за рамки естественных границ объектов предметной области.

Для таких областей есть термин "поперечные области ответственности". Инфраструктура сохранения и логика предметной
области, рассматриваемая в изоляции, может быть модульной. Проблемы возникают в точках пересечения этих областей. В
архитектуре `EJB` по отношению к сохранению объектов, безопасности и транзакциям, предвосхитил аспектно-ориентированное
программирование, которое представляет универсальный подход к восстановлению модульности для поперечных областей
видимости.

В АОП модульные конструкции, называемые аспектами, определяют, в каких точках системы поведение должно меняться в
соответствии с потребностями определенной области ответственности. Определение осуществляется декларативно или
программным механизмом.

Например, при сохранении объектов объявляется какие объекты, атрибуты и т.д. должны сохраняться и делегируем работу
сохранения своей инфраструктуре сохранения. Изменение в поведение вносятся инфраструктурой АОП без вмешательства в
целевой код.

Три "аспектно-подобных" механизма:

## 11.4 Посредники

Посредники(proxies) подходят для создания оберток для вызова методов отдельных объектов или классов. `JDK Dynamic Proxy`
работают только с интерфейсами. Посредник для класса используются библиотеки для выполнения манипуляций с байт-кодом:
`GCLIB`, `ASM` или `Javassist`.

Пример заготовки `JDK Dynamic Proxy`:

```java
// Абстрактное представление банка
interface Bank {
    Collection<Account> getAccounts();

    void setAccounts(Collection<Account> accounts);
}

// POJO-объект, реализующий абстракцию. Описывается бизнес логика
class BankImpl implements Bank {

    private List<Account> accounts;

    public Collection<Account> getAccount() {
        return accounts;
    }

    public void setAccounts(Collection<Account> accounts) {
        this.accounts = new ArrayList<>(accounts);
    }
}

// Реализация InvocationHandler, необходимая для API посредника
class BankProxyHandler implements InvocationHandler {

    private Bank bank;

    public BankProxyHandler(Bank bank) {
        this.bank = bank;
    }

    // Метод, определенный в InvocationHandler
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {

        String methodName = method.getName();
        if (methodName.equals("getAccounts")) {
            bank.setAccounts(getAccountsFromDatabase());
            return bank.getAccounts();
        } else if (methodName.equals("setAccounts")) {
            bank.setAccounts((Collection<Account>) args[0]);
            setAccountsToDatabase(bank.getAccounts());
            return null;
        } else {
            // ...
        }
    }

    // Методы взаимодействия с БД
    protected Collection<Account> getAccountsFromDatabase() {
    }

    protected void setAccountsToDatabase(Collection<Account> accounts) {
    }
}

// Клиентский код взаимодействия с посредником
class Client {
    void method() {
        Bank bank =
                (Bank)
                        Proxy.newProxyInstance(
                                Bank.class.getClassLoader(),
                                new Class[]{Bank.class},
                                new BankProxyHandler(new BankImpl()));
    }
}

```

Объем и сложность кода - два больших недостатка посредника. Если использовать библиотеки создания прокси с
использованием манипуляций байт-кода, будет не меньше проблем.

## 11.5 АОП-инфраструктуры на "чистом" Java

Большая част шаблонного кода посредников может автоматически обрабатываться вспомогательными средствами, например в
`Spring AOP`.

В `Spring` бизнес-логика записывается в форме POJO-объектов, которые не имеют зависимости во внешних инфраструктурах,
соответственно они концептуально просты и удобны в тестировании.

Вся необходимая инфраструктура приложения, включая поперечные области ответственности(сохранение объектов, транзакции,
кэширование и т.д.), определяется с помощью декларативных конфигурационных файлов или аннотаций, или API.

Каждый объект бизнес-логики "упаковывается" в декоратор, расширяющий поведение POJO-объекта.

Инфраструктуры вроде `Spring` привели к переработке стандарта `EJB` до версии 3:

```java

@Entity
@Table(name = "banks")
public class Bank implements Serializable {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private int id;

    @Embeddable
    public class Address {
        protected String streetAddr1;
        protected String streetAddr2;
        protected String city;
        protected String state;
        protected String zipCode;
    }

    @Embedded
    private Address address;

    @OneToMany(cascade = CascadeType.ALL, fetch = FetchType.EAGER, mappedBy = "bank")
    private Collection<Account> accounts = new ArrayList<>();

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public void addAccount(Account account) {
        account.setBank(this);
        account.add(account);
    }

    public Collection<Account> getAccounts() {
        return accounts;
    }

    public void setAccounts(Collection<Account> accounts) {
        this.accounts = accounts;
    }
}

```

Этот вариант гораздо чище, чем код на `EJB2`. Все инфраструктурные подробности описываются в аннотациях, оставляя код
бизнес-логику.

## 11.6 Аспекты AspectJ

Самым полнофункциональным инструментом для разделения областей ответственности посредством аспектов является `AspectJ` -
аспектно-ориентированное расширение `Java`.

Чистые Java-решения(`Spring`, `JBoss`) охватывает 80-90% ситуаций, в которых применяется аспекты. Тем не менее `AspectJ`
предоставляет гораздо широкий инструментарий.

## 11.7 Испытание системной архитектуры

Радикальные изменения в программных продуктах могут оказаться экономически оправданными - при условии, что в программном
проекте эффективно реализованно разделение ответственности.

Оптимальная архитектура системы состоит из модульных областей ответственности, каждая из которых реализуется на базе
POJO-объектов. Области интегрируются между собой при помощи аспектов или аналогичных средств, минимальным образом
вмешивающихся в их работу. Такая архитектура может строиться на базе методологии разработки через тестирование, как и
программный продукт.

## 11.8 Оптимизация принятия решений

Гибкость POJO-системы с модульными областями ответственности позволяет принимать оптимальное, своевременное решения на
базе новейшей информации. Кроме того, он способствует снижению сложности таких решений.

## 11.9 Применяйте стандарты разумно, когда они приносят очевидную пользу

Стандарты упрощают повторное использование идей и компонентов, привлечение людей с необходимым опытом, воплощение
удачных идей и связывание компонентов. Тем не менее, процесс создания стандарта иногда занимает слишком много времени (а
отрасль не стоит на месте), в результате чего стандарты теряют связь с реальными потребностями тех людей, которым они
должны служить.

### 11.9.1 Системам необходимы предметно-ориентированные языки

Хороший предметно-ориентированный язык сводит к минимуму "коммуникационный разрыв" между концепцией предметной области и
кодом, реализующий эту концепцию.

Предметно-ориентированные языки позволяют выразить в форме POJO-объектов все уровни абстракции и все предметные области
приложения, от высокоуровневых политик до низкоуровневых технических подробностей.

# 12 Формирование архитектуры

## 12.1 Четыре правила

Правила простой архитектуры Кента Бека:

* Обеспечивает прохождение всех тестов
* Не содержит дублирующего кода
* Выражает намерения программиста
* Использует минимальное количество классов и методов

### 12.1.1 Правило №1: выполнение всех тестов

Система, протестированная и прошедшая все тесты, контролируемая. Не возможно проверить работу системы, которая не
является контролируемой, а непроверенные системы не должны запускаться в эксплуатацию.

Стремление к контролируемости системы ведет к архитектуре с компактными узкоспециализированными классами,
соответствующие принципу едино обветренности, которые проще тестировать. А чем больше тестов напишем, тем больше
обеспечим контролируемость.

### 12.1.2 Правило №2-4: переработка кода

Когда есть полный набор тестов, можно заняться чисткой кода и классов - рефакторингом. В этой фазе применяются все
подходящие приемы: повышения связанности, устранение жестких привязок, разделение ответственности и т.д. Также три
критерия простой архитектуры: устранение дубликатов, обеспечение выразительности и минимизация количества классов и
методов.

#### 12.1.2.1 Отсутствие дублирования

Дублирование - главный враг хорошо спроектированной системы. Его последствия - лишняя работа, лишний риск и лишняя
избыточная сложность.

Точное совпадение строк свидетельствует о дублировании. Но также дублирование может присустваовать в реалзиации:

```java
class Example {
    int size() {
    }

    boolean isEmpty() {
    }
}

```

Методы имеют разные реализации: `size` - счетчик элементов, `isEmpty` - логический флаг. Можно устранить дублирование в
реализации: `boolean isEmpty() {return 0 == size();}`

**Повторное использование даже в мелочах**. Чтобы создать чистую систему, нужно стремиться к устранению дублей, даже в
нескольких строк кода одного класса. После выделение этих общих конструкций начинают проявляться нарушение **Принципа
единственной ответственности** и сформированный общий код можно переместить в другой класс. Это расширит область
видимости для данной сущности и другой участник разработки может его использовать в другой части системы.

Паттерн **Шаблонный метод** стандартный прием устранения высокоуровневого дублирования.

#### 12.1.2.2 Выразительность

Легко написать код, понятный для нас самих, потому что в этот момент мы глубоко понимаем решаемую задачу. У других
программистов сопровождающий код, такого понимания не будет.

Основные затраты проекта связаны с его сопровождением. Требует много времени, чтобы разобраться сложных системах, плюс
если эти системы имеют запутанный код.

Что дает выразительность:

* Хороший выбор имен
* Небольшой размер классов и функций
* Стандартная номенклатура. Например, при использовании паттернов **Команда** или **Посетитель**, добавлять в название
  классов соответсвующее название паттернов
* Хорошо написаны модульные тесты. Они рассматриваются как разновидность документации
* Всегда стараться сделать код выразительным, а не гнаться за новыми задачами

#### 12.1.2.3 Минимум классов и методов

Многочисленность мелких классов и методов иногда является результатом бессмысленного догматизма. Например:

* Стандарт кодирования который требует создания интерфейса для каждого без исключения класса
* Поля данных и поведение всегда должны быть разделены на классы данных и классы поведения

Необходимо избегать подобных догм, а в своей работе руководствоваться более прагматичным подходом.

Цель сделать систему компактной, но при этом сохранить компактность функций и классов.

# 13 Многопоточность

## 13.1 Зачем нужна многопоточность?

Многопоточное программирование помогает отделить выполняемую операцию от момента её выполнения. Что позволяет улучшить
производительность, так и структуру приложения. Структура многопоточных приложений выглядит как взаимодействие
нескольких компьютеров, а не один большой управляющий цикл. Такая структура упрощает понимание системы и дает средства
для разделения ответственности.

### 13.1.1 Мифы и неверные представления

Мифы:

* Многопоточность всегда повышает быстродействие
* Написание многопоточного кода не изменяет архитектуру программы
* При работе с контейнерами (например, веб-контейнерами или EJB-контейнерами) разбираться в проблемах многопоточного
  программирования не обязательно.

Утверждения, которые относятся к написанию многопоточного кода:

* Многопоточность сопряжена с определёнными дополнительными затратами - в отношении как производительности, так и
  написания дополнительного кода
* Правильная реализация многопоточность сложна даже для простых задач
* Ошибки в многопоточном коде обычно не воспроизводятся, поэтому они часто игнорируются как случайные отклонения (а не
  как систематические дефекты, которыми они на самом деле являются)
* Многопоточность часто требует фундаментальных изменений в стратегии проектирования

## 13.2 Трудности

Пример:

```java
class X {
    private int lastIdUsed;

    public int getNextId() {
        return ++lastIdUsed;
    }
}

```

Если создать экземпляр класс `X` со `lastIdUsed = 42` и вызывать `getNextId()` в других потоках, возможны три исхода:

1. Первый поток получит значение 43, второй 44, в поле `lastIdUsed` сохраняется 44
2. Первый поток получит значение 44, второй 43, в поле `lastIdUsed` сохраняется 44
3. Первый поток получит значение 43, второй 43, в поле `lastIdUsed` сохраняется 43

## 13.3 Защита от ошибок многопоточности

### 13.3.1 Принцип единой ответственности

Многопоточные архитектуры сложны, чтобы их можно рассматривать как причина изменения сами по себе, а следовательно,
они должны отделяться от основного кода.

При разработке нужно учитывать следующие факторы:

* Код реализации многопоточности имеет собственный цикл разработки, модификации и настройки
* При написании кода реализации многопоточности возникают специфические сложности, принципиально отличающиеся от
  сложностей однопоточного кода (и частно превосходящие их)
* Количество потенциальных сбоев в неверно написанном многопоточном коде достаточно велико и без дополнительного бремени
  в виде отгружающего кода приложения

### 13.3.2 Следствие: ограничивайте область видимости данных

Когда несколько потоков меняют одно общее поле это может привести к непредвиденному поведению. Возможное решение защита
критической секций кода словом `synchronized`. Чем больше таких мест, тем с большей вероятностью:

* Вы забудете защитить одно или несколько из этих мест, что приведет к нарушению работы всего кода, изменяющего общие
  данные
* Попытки уследить за тем, чтобы все было надежно защищено, приведут к дублированию усилий

### 13.3.3 Следствие: потоки должны быть как можно более независимы

Нужно стараться писать код, чтобы каждый поток существовал в собственном замкнутом пространстве и не использовал данные
совместно. Каждый поток обрабатывает только одни клиентский запрос, его данные берутся из отдельного источника и
хранятся в локальных переменных. Так поток работает, как будто других потоков не существует.

## 13.4 Знайте свою библиотеку

Конкретно при использовании `Java 5` для многопоточного кода следует руководствоваться следующими правилами:

* Используйте потоково-безопасные коллекции
* Используйте механизм `Executor Framework` для выполнения несвязанных задач
* По возможности используйте неблокирующие решения
* Некоторые библиотечные классы не являются потоково-безопасными

### 13.4.1 Потоково-безопасные коллекции

При использовании `Java 5+`, стоит изучить пакет `java.util.concurrent`. Одни из компонентов:

* `ConcurrentHashMap` - потоково-безопасная реализация `HashMap`. Работает в целом лучше, чем стандартная HashMap, можно
  даже применять не только многопоточном коде.
* `ReentrantLock` - блокировка, которая может устанавливаться и освобождаться в разных методах
* `Semaphore` - реализация классического семафора (блокировка со счетчиком)
* `CountDownLatch` - блокировка, которая ожидает заданного количества событий до освобождения всех ожидающих потоков.
  Позволяет организовывать более или менее одновременный запуск нескольких потоков

## 13.5 Знайте модели выполнения

В контексте многопоточных приложений возможно несколько моделей логического разбиения поведения программы.
Базовые определения:

| Термин                                              | Описание                                                                                                                                                                                                                                                                                                              |
|-----------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Связанные ресурсы                                   | Ресурсы с фиксированным размером или количеством, существующие в многопоточной среде, например подключение к базе данных или буферы чтения/записи                                                                                                                                                                     |
| Взаимное исключение                                 | В любой момент времени с общими данными или с общими ресурсом может работать только один поток                                                                                                                                                                                                                        |
| Зависание                                           | Работа одно или нескольких потоков приостанавливается на слишком долгое время (или навсегда). Например, если высокоприоритетным потокам всегда предоставляется возможность отработать первыми, то низкоприоритетные потоки зависуть (при условии, что в системе постоянно появляются новые высокоприоритетные потоки) |
| Взаимная блокировка (deadlock)                      | Два и более потока бесконечно ожидают завершения друг друга. Каждый поток захватил ресурс, необходимый для продолжения работы другого потока, и ни один поток не может завершиться без получения захваченного другим потоком ресурса                                                                                  |
| Обратимая блокировка/активная блокировка (livelock) | Потоки не могут "разойтись" - каждый из потоков пытается выполнять свою работу, но обнаруживает, что другой поток стоит у него на пути. Потоки постоянно пытаются продолжить выполнение, но им не удается в течение слишком долгого времени (или вообще не удается)                                                   |

### 13.5.1 Модель "производитель-потребитель"

Производитель - потоки создающие задания и помещающие их в очередь(буфер).

Потребитель - потоки извлекающие задания из очереди и выполняют их.

Связанные ресурсы - очередь между ними, производитель дожидается появления свободного места, а потребитель дожидается
появления задания для обработки.

Координация между ними основана на передаче сигналов. Обе стороны передают сигналы, при выполнении своей работы, а также
ожидают оповещение с другой стороны.

### 13.5.2 Модель "читатели-писатели"

Связанный ресурс - источник информации.

Производитель - читающий из связанного ресурса.

Потребитель - периодические обновляет связанный ресурс.

Существует проблема оперативности обновления. Редкие обновления - накопление устаревших данных, частое - снижение
производительности. Проектировщик должен найти баланс между потребностями читателей и писателей.

### 13.5.3 Модель "обедающих философов"

https://ru.wikipedia.org/wiki/Задача_об_обедающих_философах

В многопоточной модели: философ - это поток, вилки - связанные ресурсы. Если небрежно проектировать данную модель, это
может привести к взаимным блокировкам, обратимым блокировкам, падению производительности и эффективности работы.

## 13.6 Остерегайтесь зависимостей между синхронизированными методами

Если общий класс содержит более одного синхронизированного метода, возможно, система спроектирована неверно.

Если требуется использовать несколько синхронизированных методов общего объекта, есть следующие решения:

* Блокировка на стороне клиента - клиент устанавливает блокировку для сервера перед вызовом первого метода и следит за
  тем, чтобы блокировка распространялась на код, вызывающий последний метод
* Блокировка на стороне сервера - на стороне сервера создается метода, который блокирует сервер, вызывает все методы,
  после чего снимает блокировку. Этот новый метод вызывается клиентом.
* Адаптирующий сервер - в системе создается посредник, который реализует блокировку. Ситуация может рассматриваться как
  пример блокировки на стороне сервера, в которой исходный сервер не может быть изменен.

## 13.7 Синхронизированные секции должны иметь минимальный размер

Блокировки обходятся дорого - они создают задержки и увеличивают затраты ресурсов. Код не должен лишний раз ими
перегружаться. Но все критические секции должны быть защищены. Следовательно, код должен содержать как можно меньше
критических секций.

## 13.8 О трудности корректного завершения

Реализовать корректное завершение работы системы непросто. Типичная проблема - взаимная блокировка потоков, бесконечно
ожидающих сигнала на продолжение работы.

Начинайте думать о корректном завершении на ранней стадии разработки. На это может уйти больше времени, чем вы
предполагаете. Проанализируйте существующие алгоритмы, потому что эта задача сложнее, чем кажется.

## 13.9 Тестирование многопоточного кода

Тестирование однопоточного кода не гарантирует правильность его работы, но сводит риск к минимум.

Для многопоточного кода ситуация значительно усложняется.

### 13.9.1 Рассматривайте непериодические сбои как признаки возможных проблем многопоточности

В многопоточном коде сбои происходят даже там, где их вроде бы и быть не может. Не игнорируйте системные ошибки, считая
их случайными, разовыми сбоями.

### 13.9.2 Начинайте с отладки основного кода, не связанного с многопоточным

Не пытайтесь одновременно отлавливать ошибки в обычном и многопоточном коде. Убедитесь в том, что ваш код работает за
пределами многопоточной среды выполнения.

### 13.9.3 Реализуйте переключение конфигураций многопоточного кода

Напишите вспомогательный код поддержки многопоточности, который мог работать в разных конфигурациях:

* Один поток; несколько потоков; количество потоков изменяется по ходу выполнения
* Многопоточный код взаимодействует с реальным кодом или тестовым заменителем
* Код выполняется с тествоыми заменителями, которые работают быстро; медленно; с переменной скоростью.
* Настройте тесты таким образом, чтобы они могли выполняться заданное количество раз

Реализуйте многопоточный код, чтобы он выполнялся в различных конфигурациях.

### 13.9.4 Обеспечьте логическую изоляцию конфигураций многопоточного кода

Баланс программных потоков обычно выявляется методом проб и ошибок:

1. Найдите средства измерения производительности системы в разных конфигурациях
2. Реализуйте систему, чтобы можно было изменить количество программных потоков
3. Нельзя ли разрешить его изменения во время работы системы?
4. Рассмотрите возможность автоматической настройки в зависимости от текущей производительности и загрузки

### 13.9.5 Протестируйте программу с количеством потоков, превышающим количество процессоров

При переключении контекста системы между задачами могут быть неожиданности. Чтобы это форсировать, выполняйте код с
кол-во потоков превышающим количество процессоров или ядер. Чем чаще происходит переключение задач, тем больше
вероятность выявление критической секции или взаимной блокировки.

### 13.9.6 Протестируйте программу на разных платформах

В разных операционных системах используется разные политики многопоточности, влияющие на выполнение кода. Многопоточный
код по-разному работает в разных средах. Необходимо тестировать на всех целевых платформах - часто и начиная с ранней
стадии.

### 13.9.7 Применяйте инструмент кода для повышения вероятности сбоев

Лишь несколько из тысячи возможных путей выполннения многопоточного кода плохо написанной секции приводят к фактическому
отказу. Вероятность выбора сбойного пути ничтожно мала, что усложняет выявление ошибок.

Чтобы повысить вероятность выявления редких ошибок, можно внести в код изменения и заставить его выполнятся по разным
путям - добавить вызов таких методов: `Object.wait()`, `Object.sleep()`, `Object.yield()`, `Object.priority()`.

Два способа инструментовки кода:

#### 13.9.7.1 Ручная инструментовка

Разработчик вставляет в свой код вызовы `Object.wait()`, `Object.sleep()`, `Object.yield()`, `Object.priority()`
вручную. Подходит для тестирования коварных фрагментов кода.

```java
class Main {
    public synchronized String nextUrlOrNull() {
        if (hasNext()) {
            String url = urlGenerator.next();
            Thread.yield(); // Вставлено для тестирования
            updateHasNext();
            return url;
        }
        return null;
    }
}

```

В данном методе `yield()` изменяет путь выполнения кода и сбой может произойти, где раньше не было.

Минусы:

* Разработчик должен каким-то образом найти подходящие места для вставки вызовов
* Как узнать, где и какой именно вызов вставить?
* Если вставленные вызовы останутся в окончательной версии кода, это приведет к замедлению работы
* Нужно действовать "наобум": либо найдете дефекты, либо нет

Разделение на POJO-объектов, которые отвечают за многопоточность и отвечают за предметную область - упрощает поиск
подходящих мест. Такое разделение позволяет создать набор "испытательных пактов", активизирующие POJO-объектов с разными
вызовами `wait()`, `sleep()`, `yield()`, `priority()`.

#### 13.9.7.2 Автоматизированная инструментовка

Программная инструментовка кода возможно с помощью A`spect-Oriented Framework`, `CGLIB` или `ASM`.

Например:

```java
class ThreadJigglePoint {
    public static void jiggle() {
    }
}

class Test {
    public synchronized String nextUrlOrNull() {
        if (hasNext()) {
            String url = urlGenerator.next();
            ThreadJigglePoint.jiggle();
            updateHasNext();
            ThreadJigglePoint.jiggle();
            return url;
        }
        return null;
    }
}

```

В данном коде появляется аспект, случайным образом выбирает между обычным продолжением работы, приостановкой и передачей
управления.

Также `ThreadJigglePoint` может иметь две реализации. Одна реализация с обычным выполнением кода, другая для тестов.

# 14 Последовательное очищение

## 14.1 Реализация Args

[Args.java](src%2Fmain%2Fjava%2Fru%2Fzachesov%2Flearn%2Fchapter14%2FArgs.java)

Данный код приближен к эталонному.

## 14.2 Как я это сделал?

Он получился не сразу. В начале был достаточно простой код.

## 14.3 Args: черновик

Первоначальная версия была простая и описывался только аргументы типа `boolean`.

### 14.3.1 На этом я остановился

Но при добавлении новых типов аргументов он разрастался и приходилось вносить изменения в трех местах синхронно, так
родилась концепция `ArgumentMarshaler`.

### 14.3.2 О постепенном усовершенствовании

_Более подробный разбор изменения см. в книге._

Один из верных способов убить программу - вносить глобальные изменения в её структуру с целью улучшения.

Чтобы этого не произошло можно воспользоваться методологией `TDD`. Одна из центральных её доктрин: система должна
работать в любой момент в процессе внесения изменений.

## 14.4 Последовательное очищение

_Более подробный разбор изменения см. в книге._

Добавление обработки новых типов происходил в класс `ArgumentMarshaler`. Затем реализация перенесена в подклассы, а сам
класс стал `abstract`. Потом в Args добавлен единая `Map` для разных типов.

# 15 Внутреннее строение JUnit

_Более подробный разбор изменения см. в книге._

# 16 Переработка SerialDate

_Хороший разбор. Возможно детальней рассмотреть. Более подробный разбор изменения см. в книге._

# 17 Запахи и эвристические правила

## 17.1 Комментарии

### C1: Неуместная информация

В комментариях неуместно размещать информацию, которую удобнее хранить в других источниках: в системах управления
исходным кодом, в системах контроля версиями и в др. системах протоколирования. Комментарии должны быть
зарезервированными для технической информации о коде и его архитектуре.

### C2: Устаревшая информация

Комментарии стареют довольно быстро. Не пишете комментарии, которые со временем устареют. Обновите или удалите старый
комментарий.

### C3: Избыточная информация

Избыточный комментарий - описывающий то, что и так очевидно.

`i++; // incr + 1`

### C4: Плохо написанный комментарий

Если пишите комментарий, не жалейте времени и напишите его хорошо.

### C5: Закомментированный код

Наберитесь смелости и удалите его. Такой комментарий попадает под описания выше.

## 17.2 Функции

### F1: Слишком много аргументов

Необходимо уменьшать кол-во аргументов. Лучшие функции без аргументов. Допустимы с 1-3 аргументами. Функции с 4+
сомнительны.

### F2: Выходные аргументы

Обычно ожидается, что аргумент используется в качестве входной, а не выходной информации. Если функция должна изменить
объект, лучше чтобы этот объект сам вызвал эту функцию.

### F3: Флаг в аргументах

Логические аргументы указывают, что функция выполняет более одного действия. Исключите их.

### F4: Мертвые функции

Наберитесь смелости и удалите функцию, которая не используется. Через VCS можно восстановить её.

## 17.3 Разное

### G1: Несколько языков в одном исходном файле

В идеале исходный файл должен содержать код на одном языке. Если требуется добавить ещё в файл языки, стараться свести к
минимуму их количество и объем.

### G2: Очевидное поведение не реализовано

Если очевидное поведение функции или класса не реализовано, читатели и пользователи кода перестают полагаться на свою
интуицию в отношении имен. Они теряют доверие к автору и приходится разбираться в подробности реализации.

### G3: Некорректное граничное условие

Каждая граничная ситуация, каждый необычный и особый случай способны нарушить работу элегантного и интуитивного
алгоритма. Не полагайтесь на интуицию. Найдите каждое граничное условие и напишите для него тест.

### G4: Отключенные средства безопасности

Например, ручное управление `serialVersionUID` бывает необходимо, но рискованно. Иногда отключение предупреждение
компилятора позволяет нормально программировать, но есть риск бесконечных отладочных сеансов. Не отключайте сбойные
тесты, при этом пологая, что вы пройдете их позднее.

### G5: Дублирование

Повторяющийся код указывает на упущенную возможность для абстракции(функция или отдельный класс)."Сворачивания" дублей,
расширяет лексикон языка, позволяет другим программистам пользоваться созданными абстракциями, ускоряет программирование
и снижает вероятность ошибок.

Формы дублирования:

- Повторяющиеся куски кода(объединить в методе)
- Цепочки `switch/case` или `if/else`, встречающиеся в разных модулях и всегда проверяющие одинаковые условия(заменить
  полиморфизмом)
- Сходные алгоритмы в разных модулях и со схожим(но не одинаковым) кодом(попробовать применить паттерны **Шаблонный
  метод** или **Стратегия**)

### G6: Код на неверном уровне абстракции

Абстракции - отделяют высокоуровневые общие концепции от низкоуровневых подробностей. Данное разделение должно быть
полным! Например, константы, переменные и вспомогательные функции конкретно реализации, должны храниться в производных
классах и абстрактный класс о них ничего не должен знать.

Данное правило относится к исходным файлам, компонентам и модулям.

Разделение абстракций - одна из самых сложных задач, решаемым разработчиками. Если выбор сделан неверно, не надейтесь,
что вам удастся найти простое обходное решение.

### G7: Базовые классы, зависящие от производных

Базовые классы относящиеся к более высокому уроню абстракций, ничего не должны знать о своих производных классах.

Одно из исключений, когда количество производных классов фиксировано и базовый класс выбирает между производными
классами. И эти классы размещаются в одном `jar` файле. Такая реализация встречается в конечных автоматах.

Если располагать производные и базовые классы в разных `jar` файлах, развертывание системы становится независимым. Такая
архитектура сокращает последствия от вносимых изменений и упрощает сопровождение системы в условиях реальной
эксплуатации.

### G8: Слишком много информации

Хорошие модули обладают компактными интерфейсами(API), позволяющие сделать многое минимальными средствами. Плохие модули
предоставляют широкие интерфейсы с множеством функций, которые необходимо вызвать, чтобы получить требуемый результат.

Основные моменты хорошего интерфейса(API):

* Чем меньше методов в классе, тем лучше
* Чем меньше переменных известно функции, тем лучше
* Чем меньше переменных экземпляров содержит класс, тем лучше
* Скрывайте свои данные
* Скрывайте вспомогательные функции
* Скрывайте константы и изменяемые переменные
* Не создавайте классы с большим количеством методов и полей
* Не создавайте большого количества защищенных(`protected`) переменных и функций в субклассах
* Сокращайте логические привязки за счет ограничения информации

### G9: Мертвый код

Где может содержаться мертвый код:

* В теле команды `if`, которая никогда не вызывается
* Содержится в секции `catch` для блока `try`, никогда не инициирующего исключение
* Во вспомогательных методах, которые никогда не вызываются
* Никогда не встречающихся условиях `switch/case`

Мертвый код не обновляется с обновлением архитектуры и не соответствует новым конвенциям и правилам.

Наберитесь мужества и похороните его.

### G10: Вертикальное разделение

* Локальные переменные должны объявляться непосредственно перед первым использованием(не более 100 строк) и должны
  обладать небольшой вертикальной областью видимости
* Приватные функции должны определяться сразу же после первого использования

### G11: Непоследовательность

Все похожие операции должны выполняться похоже. Нужно ответственно выбирать новые схемы и обозначения, если уже
выбрали - продолжайте следовать им.

### G12: Балласт

* Конструктор по умолчанию без реализации
* Неиспользуемые переменные
* Невызываемые функции
* Бессодержательные комментарии

Поддерживайте чистоту кода и не допускайте появления балласта.

### G13: Искусственные привязки

Искусственной считается привязка между двумя модулями, не имеющая явной, непосредственной цели. Например, обобщенный
`enum` в более конкретном классе, или статистические функции общего назначения, объявляемым в конкретном классе.

Как правило, это возникает из-за размещения кода в удобном месте, но не подходящим.

### G14: Функциональная зависть

Для методов класса должны быть важны переменные и функции того класс, которому он принадлежит, а не переменные и функции
других классов. Иначе возникает "функциональная зависть".

Пример:

```java
class HourlyPayCalculator {
    public Money calculateWeeklyPay(HourlyEmployee e) {
        int tenthRate = e.getTenthRate();
        int tenthsWorked = e.getTenthsWorked();
        int straightTime = Math.min(400, tenthsWorked);
        int overTime = Math.min(0, tenthsWorked - straightTime);
        int straightPay = straightTime * tenthRate;
        int overtimePay = (int) Math.round(overTime * tenthRate * 1.5);
        return new Money(straightPay + overtimePay);
    }
}

```

Но иногда это бывает необходимым, чтобы класс которому "завидуют" был менее зависимым от логики класса, где его
используют.

Пример, когда формат вывода строки, лучше не привязыват к целевому объекту.

```java
public class HourlyEmployeeReport {
    private HourlyEmployee employee;

    public HourlyEmployeeReport(HourlyEmployeeReport e) {
        this.employee = e;
    }

    String reportHours() {
        return String.format(
                "Name: %s\tHours:%d.%1d\n",
                employee.getName(), employee.getTenthsWorked() / 10, employee.getTenthsWorked() % 10);
    }
}

```

_Пример: мапперы._

### G15: Аргументы-селекторы

Аргумент селектор - аргумент метода, влияющий на поведения самого метода. Смысл аргумента сложно запомнить.

Пример:

```java
public class Example {
    public int calculateWeeklyPay(boolean overtime) {
        int tenthRate = getTenthRate();
        int tenthsWorked = getTenthsWorked();
        int straightTime = Math.min(400, tenthsWorked);
        int overTime = Math.max(0, tenthsWorked - straightTime);
        int straightPay = straightTime * tenthRate;
        double overtimeRate = overtime ? 1.5 : 1.0 * tenthRate;
        int overtimePay = (int) Math.round(overTime * overtimeRate);
        return straightPay + overtimePay;
    }
}

```

Поведение функции зависит от флага параметра метода. Её лучше разделить на 3 метода:

```java
public class Example {

    public int overTimePay() {
        int overTimeTenths = Math.max(0, getTenthsWorked() - 400);
        int overtimePay = overTimeBonus(overTimeTenths);
        return straightPay() * overtimePay;
    }

    public int straightPay() {
        return getTenthRate() * getTenthsWorked();
    }

    private overTimeBonus(int overTimeTenths) {
        double bonus = 0.5 * getTenthRate() * overTimeTenths;
        return (int) Math.round(bonus);
    }
}

```

### G16: Непонятные намерения

Что скрывает намерения автора:

* Слишком длинные выражения
* Венгерская запись
* "Волшебные числа"

Такая запись компактная и плотная, но трудно в ней разобраться.

```java
public class Example {

    public int m_otCalc() {
        return iThsWkd * iThsRte + (int) Math.round(0.5 * iThsRte * Math.max(0, iThsWkd - 400));
    }
}

```

### G17: Неверное размещение

Одно из самых важных решений - место размещения кода. Нужно следовать принципу "наименьшего удивления" - код нужно
размещать там, где читатель ожидает его увидеть.

### G18: Неуместные статические методы

`Math.max(double a, double b)` - хороший статический метод. Все данные для выполнения берутся из аргументов, а не из
объекта класса метода. И полиморфным метод не потребуется делать.

`HourlyPayCalculator.calculatePay(employee, overtimeRate)` - данная функция берет большую часть данных из своих
аргументов. Также возможно потребуется полиморфный вызов метода при реализации нескольких алгоритмов, например
`OvertimeHourlyPayCalculator` и `StraightTimeHourlyPayCalculator`, и для этого функция не может быть статистической.
Более подходящее было бы перенести в класс объекта `employee`.

Отдавать предпочтение нестатистическому методу методам статистическим, если сомневаетесь. Если точно уверены, что
функция должна быть статистической, удостоверьтесь, что от нее не потребуется полиморфное поведение.

### G19: Используйте пояснительные переменные

Разбить обработку данных на промежуточные значения, хранящиеся в переменных с содержательными именами:

```java
public class Example {
    public void method() {
        Matcher match = headerPattern.matcher(line);
        if (match.find()) {
            String key = match.group(1);
            String value = match.group(2);
            headers.put(key.toLowerCase(), value);
        }
    }
}

```

Как правило, чем больше пояснительных переменных, тем лучше.

### G20: Имена функций должны описывать выполняемую операцию

`Date newDate = date.add(5);`

Что делает данная функция? Варианты:

1. Прибавляет пять дней к `date`?
2. Или пять недель, или часов?
3. Изменяет экземпляр `date`?
4. Возвращает новое значение без изменения старого?

Если **п.1** лучше назвать `addDaysTo` или `increaseByDays`. Если **п.4**, то лучше `daysLater` или `daysSince`.

Если приходится обращаться к реализации или документации, чтобы понять, что делает метод, лучше подобрать другое имя или
разбить функциональность на меньшие функции.

### G21: Понимание алгоритмов

Непонимание алгоритмов заставляют программу работать "грубой силой", набивая её командами `if` и флагами. Лучше
остановиться и подумать, что тут происходит.

Если был определен алгоритм и успешно выполнились все тесты, но потом в нем приходится затыкать "щели". То лучше достичь
полного понимания работы алгоритмов.

Одни из лучших способов, чтобы понять, что делает функция и её алгоритм - разбить функцию на фрагменты чистые и
выразительны.

### G22: Преобразование логических зависимостей в физические

Если один модуль зависит от другого, зависимость должна быть не только логической, но и физической. Зависимый модуль
не должен делать никаких предположений относительно от модуля зависимости.

Пример:

```java
public class HourlyReporter {
    private HourlyReportFormatter formatter;
    private List<LineItem> page;
    private final int PAGE_SIZE = 55;

    public HourlyReporter(HourlyReportFormatter formatter) {
        this.formatter = formatter;
        page = new ArrayList<LineItem>();
    }

    public void generateReport(List<HourlyEmployee> employees) {
        for (HourlyEmployee e : employees) {
            addLineItemToPage(e);
            if (page.size() == PAGE_SIZE) printAndClearItemList();
        }
        if (page.size() > 0) printAndClearItemList();
    }

    private void printAndClearItemList() {
        formatter.format(page);
        page.clear();
    }

    private void addLineItemToPage(HourlyEmployee e) {
        LineItem item = new LineItem();
        item.name = e.getName();
        item.hours = e.getTenthsWorked() / 10;

        item.tenths = e.getTenthsWorked() % 10;
        page.add(item);
    }

    public class LineItem {
        public String name;
        public int hours;
        public int tenths;
    }
}

```

Логическая зависимость этого кода - знание класса `HourlyReporter` о `PAGE_SIZE`, о нем должен
знать `HourlyReportFormatter`. Это факт [неверного размещения](#g17-неверное-размещение). Если какая то
реализация `HourlyReportFormatter` не сможет работать с таким количеством страниц, произойдет ошибка.

Чтобы создать физическую зависимость, можно включить в `HourlyReportFormatter` метод `getMaxPageSize()` и использовать
его вместо константы `PAGE_SIZE`.

### G23: Используйте полиморфизм вместо if/else или switch/case

Правило "Одной команды `switch`": для каждого типа выбора программа не должна содержать более одной команды `switch`.
Множественные конструкции `switch` следует заменять полиморфными объектами.

### G24: Соблюдайте стандартные конвенции

Команды должны соблюдать единые стандарты кодирования, основанные на отраслевых нормах. Он определяет: где объявляются
переменные экземпляров; как присваиваются имена классов, методов и переменных; где размещаться фигурные скобки.
Документа с описанием не нужен - сам код служит примером оформления.

### G25: Заменяйте "волшебные числа" именованными константами

Присутствие "сырых" чисел в коде нежелательно, их следует скрыть в константах с содержательными именами.

Например, `86400` следует скрыть в константе `SECOND_PER_DAY` или если в странице отчета `55` строк то это число можно
скрыть `LINES_PER_PAGE`.

Некоторые числа легко узнаются и их не обязательно скрывать за именами констант - при условии, что они используют в
сочетании с предельно ясным кодом. Пример:

`double milesWalked = feetWalked/5280.0;`

`int dailyPay = hourlyRate * 8;`

`double circumference = radius * Math.PI * 2;`

Такие константы, как число Пи тоже узнаваемы и не всегда требуется скрывать в константе. Но есть вероятность сделать
ошибку в числе с большим количеством чисел.

Волшебное число может быть также лексемой, которые не самодокументирующими. Например:

`assertEquals(7777, Employee.find("John Doe").employeeNumber());`

Лучше указать в таком формате:

`assertEquals(HOURLY_EMPLOYEE_ID, Employee.find(HOURLY_EMPLOYEE_NAME).employeeNumber());`

### G26: Будьте точны

Принимая решение в своем коде, действуйте предельно точно и аккуратно. Понимайте, почему принимается решение и как нужно
поступить с исключениями из правил. Не ленитесь обеспечивать точность:

* Если вызывается функция, которая может вернуть `null` - проверти возвращаемое значение
* Если запрашивается запись из БД, которая должна быть единственная, проверьте не вернул ли запрос ещё запись
* Для денежных сумм используйте целые и округляйте результат по действующим правилам
* Если в программе существует возможность одновременного обновление в БД, реализуйте одну из разновидностей блокировки

### G27: Структура важнее конвенций

Архитектурные решения на уровне структуры кода важнее стандартов и конвенций. Например, конструкция `switch/case` с
хорошо выбранными именами элементов перечисления уступают базовым классам с абстрактными методами. Но при
использовании `switch/case` можно делать различную реализацию для одних типов, при этом базовые классы заставляют
реализовывать все абстрактные методы.

### G28: Инкапсулируйте условные конструкции

Выразительное условие:

`if(shouldBeDeleted(timer))`

Не выразительное условие:

`if(timer.hasExpired() && !timer.isRecurrent())`

### G29: Избегайте отрицательных условий

Отрицательные условия немного сложнее для понимания, чем положительные.

Отрицательное условие

`if(!buffer.shouldNotCompact())`

Положительное предпочтительнее:

`if(buffer.shouldCompact())`

### G30: Функции должны выполнять одну операцию

Часто функции разделяются на несколько условных секций, которые выполняют свою операцию. Следует разделить такие функции
на более мелкие с одной операцией.

Три операции в одной:

```java
class Example {
    public void pay() {
        for (Employee e : employees) {
            if (e.isPayday()) {
                Money pay = e.calculatePay();
                e.deliverPay(pay);
            }
        }
    }
}

```

Разделенная функция:

```java
class Example {
    public void pay() {
        for (Employee e : employees) payIfNecessary(e);
    }

    private void payIfNecessary(Employee e) {
        if (e.isPayday()) calculateAndDeliverPay(e);
    }

    private void calculateAndDeliverPay(Employee e) {
        Money pay = e.calculatePay();
        e.deliverPay(pay);
    }
}

```

### G31: Скрытые временные привязки

Временные привязки необходимы, но они не должны скрываться.

Пример со скрытой привязкой:

```java
public class MoogDiver {
    Gradient gradient;
    List<Spline> splines;

    public void dive(String reason) {
        saturateGradient();
        reticulateSplines();
        diveForMoog(reason);
    }
}

```

Последовательность вызова методов важна, но другой программист может поменять её без ограничений. Для этого необходимо
реализовать "эстафету", каждая функция выдает результат необходимый для следующей.

```java
public class MoogDiver {
    Gradient gradient;
    List<Spline> splines;

    public void dive(String reason) {
        Gradient gradient = saturateGradient();
        List<Spline> splines = reticulateSplines(gradient);
        diveForMoog(splines, reason);
    }
}

```

Это сочетания увеличивает сложность функций, но это обусловлено сложностью временной привязки.

### G32: Структура кода должна быть обоснована

Структура кода должна выбираться строго по определенным причинам. Эти причины должны быть хорошо выражены в структуре
кода.

### G33: Инкапсулируйте граничные условия

Отслеживать граничные условия сложно, желательно разместить их в одно место.

```java
public class Example {

    void method() {
        if (level + 1 < tags.length) {
            parts = new Parse(body, tags, level + 1, offset + endTag);
            body = null;
        }
    }
}

```

Здесь `level + 1` граничное условие, которое дублируется. Можно его вынести в переменную.

```java
public class Example {

    void method() {
        int nextLevel = level + 1;
        if (nextLevel < tags.length) {
            parts = new Parse(body, tags, nextLevel, offset + endTag);
            body = null;
        }
    }
}

```

### G34: Функции должны быть написаны на одном уровне абстракции

Все команды должны быть сформулированы на одном уровне абстракции, который расположен одним уровнем ниже операции,
описываемой именем функции.

Придерживаться этому правилу сложно, но программисты справляются со смешением разных уровней абстракции.

```java
public class Example {

    public String render() {
        StringBuffer html = new StringBuffer("<hr");
        if (size > 0) html.append(" size=\"").append(size + 1).append("\"");
        html.append(">");
        return html.toString();
    }
}

```

В данном примере смешиваются минимум два уровня:

1. Наличие толщины у горизонтальной линии
2. Синтаксис тега `HR`

Переработанная версия:

```java
public class Example {

    public String render() {
        HtmlTag hr = new HtmlTag("hr");
        if (extraDashes > 0) hr.addAttribute("size", hrSize(extraDashes));
        return hr.html();
    }

    private String hrSize(int height) {
        int hrSize = height + 1;
        return String.format("%d", hrSize);
    }
}

```

При разбиении функции на уровни абстракции иногда обнаруживаются новые уровни, скрытые прежней структурой.

### G35: Храните конфигурационные данные на высоких уровнях

Константы, определяющие значение по умолчанию или параметр конфигурации - должны располагаться на высоких уровнях
абстракций, а не храниться в низкоуровневой функции.

```java
public class Example {

    public static void main(String[] args) throws Exception {
        Arguments arguments = parseCommandLine(args);
    }

    public class Arguments {
        public static final String DEFAULT_PATH = ".";
        public static final String DEFAULT_ROOT = "FitNesseRoot";
        public static final int DEFAULT_PORT = 80;
        public static final int DEFAULT_VERSION_DAYS = 14;
    }
}

```

Константы `Arguments` задаются в начале класса.

Конфигурационные константы находятся на очень высоком уровне и их легко можно изменить. И передаются на нижние уровни.

### G36: Избегайте транзитивных обращений

Модуль не должен обладать слишком полной информацией о тех компонентах, с которыми он взаимодействует. Если **А**
взаимодействует с **B**, а **B** взаимодействует с **С**, то **A** ничего не должно знать об **C**. Может появиться
что-то типа `a.getB().getC()`. Иногда это называется "законом Деметры".

Модули не должны располагать навигационной картой о всей системе.

Иначе это приведет к трудностям изменения архитектуры, например вставкой между слоями, дополнительного слоя. Так
появляются закостеневшие архитектуры.

## 17.4 Java

### J1: Используйте обобщенные директивы импорта

