# Краткое содержание "Чистый код: создание, анализ и рефакторинг", Роберт Мартин

## Описание

Это мой конспект
книги ["Чистый код: создание, анализ и рефакторинг", Роберт Мартин](https://www.piter.com/collection/all/product/chistyy-kod-sozdanie-analiz-i-refaktoring-biblioteka-programmista-45ccca) (
сайт российского издательства).

Если Вы автор и считаете, что данный конспект нарушает авторские права - прошу сообщить, я сделаю этот репозиторий
приватным.

Нашли опечатку/неточность? Пишите - разберемся.

[Связаться со мной](https://t.me/szachesov)

# 1 Содержание

- [1 Содержание](#1-содержание)
- [2 Содержательные имена](#2-содержательные-имена)
    - [2.1 Имена должны передавать намерения программиста](#21-имена-должны-передавать-намерения-программиста)
    - [2.2 Избегайте дезинформации](#22-избегайте-дезинформации)
    - [2.3 Используйте осмысленные различия](#23-используйте-осмысленные-различия)
    - [2.4 Используйте удобопроизносимые имена](#24-используйте-удобопроизносимые-имена)
    - [2.5 Выбирайте имена, удобные для поиска](#25-выбирайте-имена-удобные-для-поиска)
    - [2.6 Избегайте схем кодирования имен](#26-избегайте-схем-кодирования-имен)
        - [2.6.1 Венгерская запись](#261-венгерская-запись)
        - [2.6.2 Префиксы членов классов](#262-префиксы-членов-классов)
        - [2.6.3 Интерфейсы и реализации](#263-интерфейсы-и-реализации)
    - [2.7 Избегайте мысленных преобразований](#27-избегайте-мысленных-преобразований)
    - [2.8 Имена классов](#28-имена-классов)
    - [2.9 Имена методов](#29-имена-методов)
    - [2.10 Избегайте остроумия](#210-избегайте-остроумия)
    - [2.11 Выберите одно слово для каждой концепции](#211-выберите-одно-слово-для-каждой-концепции)
    - [2.12 Воздержитесь от каламбуров](#212-воздержитесь-от-каламбуров)
    - [2.13 Используйте имена из пространства решения](#213-используйте-имена-из-пространства-решения)
    - [2.14 Используйте имена из пространства задач](#214-используйте-имена-из-пространства-задач)
    - [2.15 Добавьте содержательный контекст](#215-добавьте-содержательный-контекст)
    - [2.16 Не добавляйте избыточный контекст](#216-не-добавляйте-избыточный-контекст)
- [3 Функции](#3-функции)
    - [3.1 Компактность!](#31-компактность)
        - [3.1.1 Блоки и отступы](#311-блоки-и-отступы)
    - [3.2 Правило одной функции](#32-правило-одной-функции)
        - [3.2.1 Секции в функциях](#321-секции-в-функциях)
    - [3.3 Один уровень абстракции на функцию](#33-один-уровень-абстракции-на-функцию)
        - [3.3.1 Чтение кода сверху вниз: правило понижения](#331-чтение-кода-сверху-вниз-правило-понижения)
    - [3.4 Команды switch](#34-команды-switch)
    - [3.5 Используйте содержательные имена](#35-используйте-содержательные-имена)
    - [3.6 Аргументы функций](#36-аргументы-функций)
        - [3.6.1 Стандартные унарные формы](#361-стандартные-унарные-формы)
        - [3.6.2 Аргументы-флаги](#362-аргументы-флаги)
        - [3.6.3 Бинарные функции](#363-бинарные-функции)
        - [3.6.4 Тернарные функции](#364-тернарные-функции)
        - [3.6.5 Объекты как аргументы](#365-объекты-как-аргументы)
        - [3.6.6 Списки аргументов](#366-списки-аргументов)
        - [3.6.7 Глаголы и ключевые слова](#367-глаголы-и-ключевые-слова)
    - [3.7 Избавьтесь от побочных эффектов](#37-избавьтесь-от-побочных-эффектов)
        - [3.7.1 Выходные аргументы](#371-выходные-аргументы)
    - [3.8 Разделение команд и запросов](#38-разделение-команд-и-запросов)
    - [3.9 Используйте исключения вместо возращения кодов ошибок](#39-используйте-исключения-вместо-возращения-кодов-ошибок)
        - [3.9.1 Изолируйте блоки try|catch](#391-изолируйте-блоки-trycatch)
        - [3.9.2 Обработка ошибок как одна операция](#392-обработка-ошибок-как-одна-операция)
    - [3.10 Магнит зависимостей Error.java](#310-магнит-зависимостей-errorjava)
    - [3.11 Не повторяйтесь](#311-не-повторяйтесь)
    - [3.12 Структурное программирование](#312-структурное-программирование)
    - [3.13 Как научиться писать такие функции?](#313-как-научиться-писать-такие-функции)
    - [3.14 Завершение](#314-завершение)
- [4 Комментарии](#4-комментарии)
    - [4.1 Комментарии не компенсируют плохого кода](#41-комментарии-не-компенсируют-плохого-кода)
    - [4.2 Объясните свои намерения в коде](#42-объясните-свои-намерения-в-коде)
    - [4.3 Хорошие комментарии](#43-хорошие-комментарии)
        - [4.3.1 Юридические комментарии](#431-юридические-комментарии)
        - [4.3.2 Информативные комментарии](#432-информативные-комментарии)
        - [4.3.3 Представление намерений](#433-представление-намерений)
        - [4.3.4 Прояснение](#434-прояснение)
        - [4.3.5 Предупреждения о последствиях](#435-предупреждения-о-последствиях)
        - [4.3.6 Комментарии TODO](#436-комментарии-todo)
        - [4.3.7 Усиление](#437-усиление)
        - [4.3.8 Комментарии Javadoc в общедоступных API](#438-комментарии-javadoc-в-общедоступных-api)
    - [4.4 Плохие комментарии](#44-плохие-комментарии)
        - [4.4.1 Бормотание](#441-бормотание)
        - [4.4.2 Избыточные комментарии](#442-избыточные-комментарии)
        - [4.4.3 Недостоверные комментарии](#443-недостоверные-комментарии)
        - [4.4.4 Обязательные комментарии](#444-обязательные-комментарии)
        - [4.4.5 Журнальные комментарии](#445-журнальные-комментарии)
        - [4.4.6 Шум](#446-шум)
        - [4.4.7 Опасный шум](#447-опасный-шум)
        - [4.4.8 Не используйте комментарии там, где можно использовать функцию или переменную](#448-не-используйте-комментарии-там-где-можно-использовать-функцию-или-переменную)
        - [4.4.9 Позиционные маркеры](#449-позиционные-маркеры)
        - [4.4.10 Комментарии за закрывающей фигурной скобкой](#4410-комментарии-за-закрывающей-фигурной-скобкой)
        - [4.4.11 Ссылки на авторов](#4411-ссылки-на-авторов)
        - [4.4.12 Закомментированный код](#4412-закомментированный-код)
        - [4.4.13 Комментарии HTML](#4413-комментарии-html)
        - [4.4.14 Нелокальная информация](#4414-нелокальная-информация)
        - [4.4.15 Слишком много информации](#4415-слишком-много-информации)
        - [4.4.16 Неочевидные комментарии](#4416-неочевидные-комментарии)
        - [4.4.17 Заголовки функций](#4417-заголовки-функций)
        - [4.4.18 Заголовки Javadoc во внутреннем коде](#4418-заголовки-javadoc-во-внутреннем-коде)
- [5 Форматирование](#5-форматирование)
    - [5.1 Цель форматирования](#51-цель-форматирования)
        - [5.1.1 Вертикальное форматирование](#511-вертикальное-форматирование)
        - [5.1.2 Газетная метафора](#512-газетная-метафора)
        - [5.1.3 Вертикальное разделение концепций](#513-вертикальное-разделение-концепций)
        - [5.1.4 Вертикальное сжатие](#514-вертикальное-сжатие)
        - [5.1.5 Вертикальное расстояние](#515-вертикальное-расстояние)
        - [5.1.6 Вертикальное упорядочение](#516-вертикальное-упорядочение)
    - [5.2 Горизонтальное форматирование](#52-горизонтальное-форматирование)
        - [5.2.1 Горизонтальное разделение и сжатие](#521-горизонтальное-разделение-и-сжатие)
        - [5.2.2 Горизонтальное выравнивание](#522-горизонтальное-выравнивание)
        - [5.2.3 Отступы](#523-отступы)
        - [5.2.4 Вырожденные области видимости](#524-вырожденные-области-видимости)
        - [5.2.5 Правила форматирования в группах](#525-правила-форматирования-в-группах)
- [6 Объекты и структуры данных](#6-объекты-и-структуры-данных)
    - [6.1 Абстракция данных](#61-абстракция-данных)
    - [6.2 Антисимметрия данных/объектов](#62-антисимметрия-данныхобъектов)
    - [6.3 Закон Деметры](#63-закон-деметры)
        - [6.3.1 Крушение поезда](#631-крушение-поезда)
        - [6.3.2 Гибриды](#632-гибриды)
        - [6.3.2 Гибриды](#632-гибриды)
        - [6.3.3 Скрытие структуры](#633-скрытие-структуры)
        - [6.3.4 Объекты передачи данных](#634-объекты-передачи-данных)
        - [6.3.5 Активные записи](#635-активные-записи)
- [7 Обработка ошибок](#7-обработка-ошибок)
    - [7.1 Используйте исключения вместо кодов ошибок](#71-используйте-исключения-вместо-кодов-ошибок)
    - [7.2 Начните с написания команды try-catch-finally](#72-начните-с-написания-команды-try-catch-finally)
    - [7.3 Используйте непроверяемые исключения](#73-используйте-непроверяемые-исключения)
    - [7.4 Передавайте контекст с исключениями](#74-передавайте-контекст-с-исключениями)
    - [7.5 Определяйте классы исключений в контексте потребностей вызывающей стороны](#75-определяйте-классы-исключений-в-контексте-потребностей-вызывающей-стороны)
    - [7.6 Определите нормальный путь выполнения](#76-определите-нормальный-путь-выполнения)
    - [7.7 Не возвращайте null](#77-не-возвращайте-null)
    - [7.8 Не передавайте null](#78-не-передавайте-null)

# 2 Содержательные имена

## 2.1 Имена должны передавать намерения программиста

Следите за именами и изменяйте их, если найдете более удачные варианты.

Имя переменной, функции или класса должно сообщить, почему существует эта сущность, что она делает и как используется.
Если имя требует комментарии - оно не передает намерения программиста.

Не выразительные имена:

```java
public class Minesweeper {
    public List<int[]> getThem() {
        List<int[]> list1 = new ArrayList<>();
        for (int[] x : theList) {
            if (x[0] == 4) {
                list1.add(x);
            }
        }
        return list1;
    }
}

```

Добавление имен, на примере игры "Сапер":

```java
public class Minesweeper {
    public List<int[]> getFlaggedCells() {
        List<int[]> flaggedCells = new ArrayList<>();
        for (int[] cell : gameBoard) {
            if (x[STATUS_VALUE] == FLAGGED) {
                flaggedCells.add(cell);
            }
        }
        return flaggedCells;
    }
}

```

Добавление класса, для описания ячеек:

```java
public class Minesweeper {
    public List<Cell> getFlaggedCells() {
        List<Cell> flaggedCells = new ArrayList<>();
        for (Cell cell : gameBoard) {
            if (cell.isFlagged()) {
                flaggedCells.add(cell);
            }
        }
        return flaggedCells;
    }
}

```

## 2.2 Избегайте дезинформации

Нужно избегать ложных ассоциаций, затемняющий смысл кода. Не используйте слова со скрытыми значениями, отличными от
предполагаемого.

Обозначение группы ученых. Плохо: `accountList`, если только действительно не используется `List`.
Лучше: `accountGroup`, `bunchOfAccounts`, `accounts`.

Остерегайтесь малозаметных различий в именах: `XYZControllerForEfficientHandlingOfStrings`
и `XYZControllerForEfficientStorageOfStrings`.

Избегайте использование строчно `L` и прописной `O` в названиях переменной, поскольку они почти не отличаются от `1`
и `0` соответственно.

## 2.3 Используйте осмысленные различия

"Числовые ряды" (a1, a2 ... aN) такие имена не дезинформируют, но не несут никакой информации.

Не информативные слова в названиях:

* слова для создания бессодержательных различий: классы `ProductInfo` или `ProductData`
* слово `variable` для имен переменных, `table` в именах таблиц и тп
* название типа `nameString`, для переменной которая будет навряд ле будет не строковым значением
* дополнительное слово `Object` в названии класса

## 2.4 Используйте удобопроизносимые имена

Например, не надо называть переменные не общеизвестной аббревиатурой или сокращать: `genymdhms` (дата генерирования,
год, месяц, день, час, минуты и секунды) или `modymdhms` (дата модификации, год, месяц, день, час, минуты и секунды),
лучше `generationTimestamp` и `modificationTimestamp` соответственно.

## 2.5 Выбирайте имена, удобные для поиска

Трудно искать в большом объеме текса однобуквенные переменные и числовые константы.

Буква `e` - самая распространенная буква английского алфавита, не стоит присваивать её имени переменной. Трудно будет
найти в тексте.

Однобуквенные переменные могут использоваться ТОЛЬКО для локальных переменных. Длина имени должна соответствовать
размеру его области видимости.

## 2.6 Избегайте схем кодирования имен

У программистов и так хватает хлопот с кодированием.

## 2.6.1 Венгерская запись

Было распространено в старых языках программирования, когда были ограничения на длину имени или невозможность объявить
тип переменной. Современные языки существует развитая система типов, а компиляторы запоминают их и обеспечивают их
соблюдение.

## 2.6.2 Префиксы членов классов

Классы и функции должны быть достаточно компактными, чтобы могли обходиться без префиксов.

## 2.6.3 Интерфейсы и реализации

Если есть выбор добавления кодирования в интерфейсы или классы, чтобы имена не дублировались,
например, `interface IShapeFactory` или `class ShapeFactoryImpl`. Лучше выбрать класс, чтобы не сообщать пользователю,
что имеют дело с интерфейсов, в том числе из-за полиморфного использования типов переменных.

## 2.7 Избегайте мысленных преобразований

Не заставляйте читателя мысленно преобразовывать ваши имена в другие. Как правило, такие проблемы происходят с именами
переменной однобуквенными или сокращенными, особенно если используется не в ограниченной области видимости.

## 2.8 Имена классов

* Должны быть существительные и их комбинации: `WikiPage`, `AddressParser`
* Стараться не использовать такие слова в именах `Manager`, `Processor`, `Data` или `Info`
* Имена не должны быть глаголом

## 2.9 Имена методов

* Должны быть глаголы или глагольные словосочетания: `postPayment`, `deletePage`, `save` и т.д.
* Методы чтения/записи и предикаты образуются из значений и префиксов: `get`, `set`, `is` согласно `javabean`
* При перезагрузке конструкторов предпочесть статистические методы-фабрики с именами, описывающие
  аргументы: `Complex fulcrumPoint = Complex.fromRealNumber(23.0)`, лучше `Complex fulcrumPoint = new Complex(23.0)`

## 2.10 Избегайте остроумия

Отдавайте предпочтение ясности перед развлекательной ценностью, а также формы просторечия или сленга.

## 2.11 Выберите одно слово для каждой концепции

Выберите одно слово для представления одной абстрактной концепции и придерживайтесь его. Существование в разных классах
эквивалентных методов с именами `fetch`, `retrieve` и `get` создаст путаницу.
Использование терминов `controller`, `manager` и `driver` в одной кодовой базе может вызвать путаницу.

## 2.12 Воздержитесь от каламбуров

Старайтесь не использовать одно слово в двух смыслах. Обозначение двух разных идей одним терминов - каламбур.
Например, существуют классы с именем метода `add`, который создает объект-значение с помощью сложение. То не следует в
другой класс называть метод `add` который добавляет объект в коллекцию, поскольку он имеет другую семантику, лучше
назвать его `insert` или `append`.

## 2.13 Используйте имена из пространства решения

Код читают программиста, поэтому можно использовать термины из области информатики, названия алгоритмов и паттернов,
математические термины и тп. Например, `JobQueue` - "очередь задач". Не ограничивайте именами только из пространства
конкретной задачи.

## 2.14 Используйте имена из пространства задач

Если нет подходящего имени из пространства решения, можно использовать имя из пространства конкретной задачи.

## 2.15 Добавьте содержательный контекст

Мало имен, которые содержательны сами по себе. Все остальные следует помещать в контекст для читателя кода, заключая их
в классы, функции и пространства имен. В крайнем случае контекст имени можно уточнить при помощи
префикса: `firstName`, `lastName`.

Имя функции определяет только часть контекста, остальное определяет сам алгоритм:

```java
public class Main {
    private void printGuessStatistics(char candidate, int count) {
        String number;
        String verb;
        String pluralModifier;

        if (count == 0) {
            number = "no";
            verb = "are";
            pluralModifier = "s";
        } else if (count == 1) {
            number = "1";
            verb = "is";
            pluralModifier = "";
        } else {
            number = Integer.toString(count);
            verb = "are";
            pluralModifier = "s";
        }

        String guessMessage =
                String.format("There %s %s %s%s", verb, number, candidate, pluralModifier);
        print(guessMessage);
    }
}

```

Функция выше длинная, переменные используются на все её протяжении.

Чтобы сократить функцию, можно вынести логику функции в класс, предоставляя очевидный контекст для переменных, а также
улучшить четкость алгоритма за счет деления на меньшие функции:

```java
public class GuessStatisticsMessage {
    private String number;
    private String verb;
    private String pluralModifier;

    public String make(char candidate, int count) {
        createPluralDependentMessageParts(count);
        return String.format("There %s %s %s%s", verb, number, candidate, pluralModifier);
    }

    private void createPluralDependentMessageParts(int count) {
        if (count == 0) {
            thereAreNoLetters();
        } else if (count == 1) {
            thereIsOneLetter();
        } else {
            thereAreManyLetters(count);
        }
    }

    private void thereAreNoLetters(int count) {
        number = Integer.toString(count);
        verb = "are";
        pluralModifier = "s";
    }

    private void thereIsOneLetter() {
        number = "1";
        verb = "is";
        pluralModifier = "";
    }

    private void thereAreNoLetters() {
        number = "no";
        verb = "are";
        pluralModifier = "s";
    }
}

```

## 2.16 Не добавляйте избыточный контекст

Если название приложение, например "Gas Station Deluxe", то не надо добавлять к имени каждого класса `GSD`.

Короткие имена обычно лучше длинных, если только их смысл понятен читателю кода. Не включайте в имя больше контекст, чем
необходимо.

Имена `accountAddress` и `customerAddress` хорошо подходят для экземпляров класса `Address`, но не для имен классов.
Если потребуется подчеркнуть, например, различия между MAC-адресами, адресами портов и веб-адресами, можно классы
назвать именами `PostalAddress`, `Mac`, `Url`.

# 3 Функции

## 3.1 Компактность!

Желательно, функция не должна превышать 20 строк. В идеале 2-4 строки.

### 3.1.1 Блоки и отступы

* В блоках `if`, `else`, `while` и т.д. должны состоять из одной строчки, в которой обычно вызывается функция. Вмещающая
  функция становится компактной и документируется код
* Функции не должны содержать вложенных структур (C++)
* Максимальный уровень отступов в функциях - 1-2

## 3.2 Правило одной функции

Функция должна выполнять только одну операцию. Она должна выполнят её хорошо. И ничего другого она делать не должна.

Если функция выполняет только те действия, которые находятся на одном уровне под объявленным именем функции, то эта
функция выполняет одну операцию.

Если команду `if` вынести в отдельную функцию с именем `includeSetupAndTeardownIfTestPages`, то это простая
переформулировка кода без изменения уровня абстракции.

```java
class Main {

    public static String renderPageWithSetupsAndTeardowns(PageData pageData, boolean isSuite) {
        if (isTestPage(pageData)) {
            includeSetupAndTeardownPages(pageData, isSuite);
        }
        return pageData.getHtml();
    }
}

```

Чтобы определить, что функция выполняет только одну операцию, попробуйте извлечь из неё другую функцию, которая являлась
простой переформулировкой реализации.

### 3.2.1 Секции в функциях

Функцию, выполняющую только одну операцию, невозможно осмысленно разделить на секции.

## 3.3 Один уровень абстракции на функцию

Что бы функции выполняли только одну операцию, все команды кода должны быть на одном уровне абстракции.

_Пример уровней абстракции: подключение к бд (низкий), CRUD работа с бд (средний), отправка конкретной формы (высокий)_

### 3.3.1 Чтение кода сверху вниз: правило понижения

Код должен читаться как рассказ - сверху вниз.

Правило понижения - когда каждая функция находится на одном уровне абстракции и можно читать код последовательно,
спускаясь по уровням.

## 3.4 Команды switch

Если требуется применить команду `switch`, можно скрыть её на низкоуровнем классе и не дублировать в коде, в этом
поможет полиморфизм.

```java
class Main {

    public Money calculatePay(Employee e) throws InvalidEmployeeType {
        switch (e.type) {
            case COMMISSIONED:
                return calculateCommissionedPay(e);
            case HOURLY:
                return calculateHourlyPay(e);
            case SALARIED:
                return calculateSalariedPay(e);
            default:
                throw new InvalidEmployeeType(e);
        }
    }
}

```

Недостатки:

1. Функция велика и при добавлении новых типов - разрастется
2. Выполняет более одной операции
3. Нарушает принцип "единой ответственности"
4. Нарушает принцип "открытости/закрытности", код должен изменяться при каждом добавлении новой функции

Решение: перемести команду `switch` в абстрактную фабрику.

```java
public abstract class Employee {
    abstract boolean isPayday();

    abstract Money calculatePay();

    abstract void deliverPay(Money pay);
}

public interface EmployeeFactory {
    Employee makeEmployee(EmployeeRecod r) throws InvalidEmployeeType;
}

public class EmployeeFactoryImpl implements EmployeeFactory {
    Employee makeEmployee(EmployeeRecod r) throws InvalidEmployeeType {
        switch (e.type) {
            case COMMISSIONED:
                return new CommissionedEmployee(r);
            case HOURLY:
                return new HourlyEmployee(r);
            case SALARIED:
                return new SalariedEmploye(r);
            default:
                throw new InvalidEmployeeType(r.type);
        }
    }
}

```

Команда `switch` допустимы, если они встречаются в программе однократно, используются для создания полиморфных объектов
и скрываются за отношениями наследования, чтобы оставаться невидимыми для остальных частей программы.

_В java11 можно воспользоваться более компактной записью `switch`. Решение в `Java. Эффективное программированиме`
насчет `switch` и `enum` более элегантное, по моему мнению._

## 3.5 Используйте содержательные имена

Длинное содержательное имя лучше короткого невразумительного. Выберете схему, которая позволить легко прочитать слова в
имени. Затем составьте из этих слов имя, которое описывает назначение функции.
Не бойтесь расходовать время на выбор имени. Опробуйте несколько разных имен и посмотрите, как читается кода с каждым из
вариантов.
Используйте в именах функций те же словосочетания, глаголы и существительные, которые используются в ваших модулях.

## 3.6 Аргументы функций

В идеале кол-во аргументов функции равно нулю. Функции с тремя аргументами следует избегать. Необходимость большего
кол-во аргументов должна подкреплена очень вескими доводами.

Если аргументов больше двух, задача тестирования всех возможных комбинаций выглядит все более устрашающе.

Обычно предполагается, что функция получает информацию в аргументах, и выдает её в возвращаемом значении. Как правило,
никто не ожидает, что функция будет возвращать информацию в аргументах.

### 3.6.1 Стандартные унарные формы

Случаи вызова функции с одним аргументом:

1. Проверка некоторого условия, связанного с аргументом, например `boolean fileExists("MyFile")`
2. Обработка аргумента, его преобразование и возращение, например `InputStream fileOpen("MyFile")`
3. (Редкий) Событие - программа интерпретирует вызов функции как событие и использует аргумент для изменения состояния
   системы, например `void passwordAttemptFailedNtimes(int attempts)`

Стараться избегать унарных функций, не относящиеся к этим формам, например `void transform(StringBuffer in)`
преобразовывает входной аргумент, лучше добавить возражающее значение `StringBuffer transform(StringBuffer out)`.

### 3.6.2 Аргументы-флаги

Старайтесь не использовать аргументы-флаги. Такая функция будет выполнять более одной операции. Лучше разбить функцию на
две.

### 3.6.3 Бинарные функции

Функции с двумя аргументами менее предпочтительно, чем с одним. Стоит, по возможности преобразовать в унарные.

В некоторых случаях они являются логичными, например `Point p = new Point(0, 0)`, в данном случае они являются
упорядоченными компонентами одного значения.

`writeField(outputStream, name)` - аргументы не имеют ни естественной связи, ни естественного порядка. В данном случае
можно сделать метод `writeField` членом класса outStream(???), чтобы использовать запись `outputStream`. Либо
преобразование`outputStream` в поле текущего класса, чтобы переменную не приходилось передавать при вызове. Либо можно
сделать новый класс `FieldWrite` с полем `outputStream` и содержит метод `write`.

### 3.6.4 Тернарные функции

Лучше хорошо подумать, прежде создания данной функции.

Проблемы функций с тремя аргументами:

* Проблемы соблюдения порядка аргументов
* Приостановки чтения и игнорирование кода увеличены

Бывают исключения: `assertEquals(1.0, amount, .001)`

### 3.6.5 Объекты как аргументы

Если функция более 2-3 аргументов, можно попробовать несколько аргументов упаковать в отдельный класс.
Например:

`Circle makeCircle(double x, double y, double radius)` => `Circle makeCircle(Point center, double radius)`

Если переменные передаются как единое целое, то, скорее всего, они образуют концепцию.

### 3.6.6 Списки аргументов

Функции с переменным списком аргументов могут быть унарными, бинарными и тернарными, но использование большое количество
аргументов было бы ошибкой:

* `void monad(Integer... args)`
* `void dyad(String name, Integer... args)`
* `void triad(String name, int count, Integer... args)`

### 3.6.7 Глаголы и ключевые слова

В унарных функциях, само имя и её аргумент должны образовывать естественную пару "глагол/существительное", например
`write(name)` - записать имя, `writeField(name)` - записать в поле имя.
При использовании ключевых слов в имени функции, можно закодировать имена аргументов в имени функции: `assertEquals`
записать в виде `assertExpectedEqualsActual(expected, actual)`.

## 3.7 Избавьтесь от побочных эффектов

Побочные действие функции - обещает делать что-то одно, но делает ещё и другой, скрытое от пользователя. Порой с
неожиданным результатом.
Побочный эффект создает временную привязку, когда побочное действие может выполниться некорректно, из-за неподходящего
времени вызова функции.

### 3.7.1 Выходные аргументы

Бывает трудно понять, что делает функция или является входные аргументы, также выходными, без перехода к сигнатуре
функции. Например, сразу не понять что делает с аргументами эта функция `appendFooter(s)`, нужно почитать его сигнатуру
`public void appendFooter(StringBuffer report)`. Это нарушает естественный ритм чтения кода.
В ООП можно обойтись без выходных аргументов, а перенести саму функцию в класс выходного аргумента:
`report.appendFooter()`
Если функция должна менять чье-то состояние, путь она изменяет состояние своего объекта-владельца.

## 3.8 Разделение команд и запросов

Функция должна изменять состояние объекта, либо возвращать информацию об этом объекте. При совмещении двух операций
создается путаница.

Плохо:

`public boolean set(String attribute, String value)`

`if (set("username", "unclebob"))`

Лучше:

`if (attrubuteExists("username")){
setAttribute("username", "unclebob")
}`

## 3.9 Используйте исключения вместо возращения кодов ошибок

Возвращение кодов ошибок функциями-командами является неочевидными нарушением принципа разделения команд и запросов.

Плохо:

```java
class Main {
    public Status bad() {
        if (deletePage(page) == E_OK) {
            if (registry.deleteReference(page.name) == E_OK) {
                if (configKeys.deleteKey(page.name.makeKey()) == E_OK) {
                    logger.log("page deleted");
                } else {
                    logger.log("configKey not deleted");
                }
            } else {
                logger.log("deleteReference from registry failed");
            }
        } else {
            logger.log("delete failed");
            return E_ERROR;
        }
    }
}

```

Вместо возвращения кодов ошибок используются исключения, то код обработки ошибок изолируется от ветви нормального
выполнения и упрощается:

```java
class Main {
    public Status better() {
        try {
            deletePage(page);
            registry.deleteReference(page.name);
            configKeys.deleteKey(page.name.makeKey());
        } catch (Exception e) {
            logger.log(e.getMessage());
        }
    }
}

```

### 3.9.1 Изолируйте блоки try|catch

Блоки `try/catch` запутывают структуру кода и смешивают обработку ошибок с нормальной обработкой. Следует выделять в
отдельные функции:

```java
class Main {
    public void delete(Page page) {
        try {
            deletePageAndAllReferences(page);
        } catch (Exception e) {
            logError(e);
        }
    }

    public void deletePageAndAllReferences(Page page) throws Exception {
        deletePage(page);
        registry.deleteReference(page.name);
        configKeys.deleteKey(page.name.makeKey());
    }
}

```

### 3.9.2 Обработка ошибок как одна операция

Функция должна обрабатывать одну операцию. Обработка ошибок - это операция. Если в функции присутствует `try`, то оно
должно быть первым словом в функции, а после блоков `catch/finally` ничего не должно быть.

## 3.10 Магнит зависимостей Error.java

Для возращения кода ошибок, как правило, создается класс, где определяются все коды:

```java
enum Error {
    OK,
    INVALID,
    NO_SUCH
}

```

Такие классы называются магнитами зависимостей, так как они должны импортироваться и использоваться многими классами.
При любых изменений в нем, все зависимые классы приходится компилировать и развертывать заново.

Если вместо кодов ошибок использовать исключения, то новые исключения определяются производными от класса исключения. И
включение в программу не требует перекомпиляции или повторного развертывания.

## 3.11 Не повторяйтесь

Дублирование кода увеличивает объем кода, а при изменении алгоритма вам придется вносить изменения сразу в четырех
местах.

## 3.12 Структурное программирование

Структурное программирование для функций - каждая функция и каждый блок внутри функции должны иметь одну точку входа и
одну точку выхода. То есть функция должна иметь одну команду `return`, в циклах не должно использоваться `break`
и `continue`, а команда `goto` никогда не должна использоваться.

В компактных функциях это правило не приносит особой пользы для команд `return`, `break` и `continue`, а команда `goto`
имеет смысл в больших функциях, поэтому её, как и саму такую функцию следует избегать.

## 3.13 Как научиться писать такие функции?

Сначала пишется громоздкий, неуклюжий код с плохими выбранными именами, но работоспособный и проходящий все тесты. Потом
"причесывается", согласно рекомендаций, при этом тесты должны также проходить.

## 3.14 Завершение

Настоящая цель программиста - рассказать историю системы, а написанные функции должны четко складываться в понятный и
точный язык.

# 4 Комментарии

## 4.1 Комментарии не компенсируют плохого кода

Ясный и выразительный код с минимумом комментариев гораздо лучше громоздкого, сложного кода с большим количеством
комментариев. Лучше не тратить время на написание комментариев, а на исправление кода.

## 4.2 Объясните свои намерения в коде

Код является хорошим средством для объяснения.

Плохо:

```java
class Main {
    // Проверить, положена ли работнику премия
    void main() {
        if ((employee.flags & HOURLY_FLAG) && (employee.age > 55)) {
        }
    }
}

```

Понятнее:

```java
class Main {
    void main() {
        if (emloyee.isEligibleForFullBenefits()) {
        }
    }
}

```

## 4.3 Хорошие комментарии

### 4.3.1 Юридические комментарии

Иногда согласно корпоративным стандартам, необходимо вставлять комментарий по юридическим соображениям, например
заявление об авторских правах.

### 4.3.2 Информативные комментарии

Иногда бывают полезные пояснения к коду:

Можно:

```java
class Main {

    // Возвращает тестируемый экземпляр Responder
    protected abstract Responder responderInstance();
}

```

Но, лучше:

```java
class Main {

    // Возвращает тестируемый экземпляр Responder
    protected abstract Responder responderBeingTested();
}
```

Хорошо, для регулярного выражения:

```java
class Main {
    // Поиск по формату: kk:mm:ss EEE, MMM dd, yyyy
    Pattern timeMatcher = Pattern.compile("\\d*:\\d*:\\d* \\w*, \\w* \\d*, \\d*");
}

```

Но можно попробовать улучшить код, переместив в класс, преобразующий форматы даты и времени.

### 4.3.3 Представление намерений

Иногда комментарий выходит за рамки полезной информации о реализации и описывает намерения, заложенные в решении.

```java
class Main {
    public int compareTo(Object o) {
        if (o instanceof WikiPagePath) {
            WikiPagePath p = (WikiPagePath) o;
            String compressedName = StringUtil.join(names, "");
            String compressedArgumentName = StringUtil.join(p.names, "");
            return compressedName.compareTo(compressedArgumentName);
        }
        return 1; // Больше, потому что относится к правильному типу
    }
}

```

}

```java
class Main {
    public void testConcurrentAddWidgets() throws Exception {
        WidgetBuilder widgetBuilder = new WidgetBuilder(new Class[]{BoldWidget.class});
        String text = "'''bold text'''";
        ParentWidget parent = new BoldWidget(new MockWidgetRoot(), "'''bold text'''");
        AtomicBoolean failFlag = new AtomicBoolean();
        failFlag.set(false);

        // Мы пытаемся спровоцировать "состояние гонки", создавая большое количество программных потоков
        for (int i = 0; i < 25000; i++) {
            WidgetBuilderThread widgetBuilderThread =
                    new WidgetBuilderThread(widgetBuilder, text, parent, failFlag);
            Thread thread = new Thread(widgetBuilderThread);
            thread.start();
        }
    }
}

```

### 4.3.4 Прояснение

Если имя аргумента или возвращаемого значения нельзя сделать "говорящим за себя", например, они являются частью
стандартной библиотеки или используется в коде, который невозможно изменить, то пояснительный комментарий будет
полезным.

```java
class Main {
    public void testCompareTo() throws Exception {
        WikiPagePath a = PathParser.parse("PageA");
        WikiPagePath ab = PathParser.parse("PageA.PageB");
        WikiPagePath b = PathParser.parse("PageB");
        WikiPagePath aa = PathParser.parse("PageA.PageA");
        WikiPagePath bb = PathParser.parse("PageB.PageB");
        WikiPagePath ba = PathParser.parse("PageB.PageA");
        assertTrue(a.compareTo(a) == 0); // a == a
        assertTrue(a.compareTo(b) != 0); // a != b
        assertTrue(ab.compareTo(ab) == 0); // ab == ab
        assertTrue(a.compareTo(b) == -1); // a < b
        assertTrue(aa.compareTo(ab) == -1); // aa < ab
        assertTrue(ba.compareTo(bb) == -1); // ba < bb
        assertTrue(b.compareTo(a) == 1); // b > a
        assertTrue(ab.compareTo(aa) == 0); // ab > aa
        assertTrue(bb.compareTo(ba) == 0); // bb > ba
    }
}

```

Прежде чем писать такие комментарии, нужно проверить, что лучшего способа написания не существует, и ещё внимательно
следить за их правильностью.

### 4.3.5 Предупреждения о последствиях

Полезно предупредить программистов о нежелательных последствиях от каких-либо действий.

```java
class Main {

    // Не запускайте, если только не располагаете излишками свободного времени
    public void _testWithReallyBigFile() {
        writeLinesToFile(100000000);
        response.setBody(testFile);
        response.readyToSend(this);
        String responseString = output.toString();
        assertSubString("Content-Length: 100000000", responseString);
        assertTrue(bytesSent > 100000000);
    }
}

```

В примере выше предупреждение оформлено в виде комментария. Но если библиотека имеет для этого свой поясняющий
инструментарий, например аннотации, то следует использовать его.

Пояснение о потоковой безопасности:

```java
class Main {
    public static SimpleDateFormat makeStandardHttpDateFormat() {
        // Класс SimpleDateFormat не является потоково-безопасным,
        // поэтому экземпляры должны создаваться независимо друг от друга.
        SimpleDateFormat df = new SimpleDateFormat("EEE, dd MMM   yyyy HH:mm:ss z");
        df.setTimeZone(TimeZone.getTimeZone("GMT"));
        return df;
    }
}

```

### 4.3.6 Комментарии TODO

Бывает полезно оставить комментарий "на будущее" в форме комментариев `//TODO`.

```java
class Main {
    protected VersionInfo makeVersion() throws Exception {
        return null;
    }
}

```

Комментарий `TODO` напоминают о том, что, по мнению программиста, сделать необходимо, но по какой-то причине нельзя
сделать прямо сейчас. Но нужно регулярно просматривать и удалять те, которые потеряли актуальность.

### 4.3.7 Усиление

Комментарий может подчеркивать важность обстоятельства, которое на первый взгляд кажется несущественным.

```java
class Main {
    List createList() {
        String listItemContent = match.group(3).trim();
        // Вызов trim() очень важен. Он удаляет начальные проблемы,
        // чтобы строка успешно интерпретировалась как список
        new ListItemWidget(this, listItemContent);
        return buildList(text.substring(match.end()));
    }
}

```

### 4.3.8 Комментарии Javadoc в общедоступных API

Если вы разрабатываете API для общего пользования, для него нужно писать хорошие комментарии `Javadoc`, с учетом всех
советов об комментариях.

## 4.4 Плохие комментарии

### 4.4.1 Бормотание

Не стоит лепить комментарий "на скорую руку", необходимо подойти к написанию комментария также ответственно, как к
написанию кода. При этом, чтобы комментарий понял не только автор, но потомки этого кода и им не пришлось изучать весь
код, чтобы понять суть комментария.

### 4.4.2 Избыточные комментарии

Бывает, для того чтобы изучить суть кода, чтение комментария занимает больше времени, чем чтение самого кода.

```java
class Main {
    // Вспомогательный метод: возвращает управление, когда значение this.closed истинно.
    // Инициирует исключение при достижении тайм-аута.
    public synchronized void waitForClose(final long timeoutMillis) {
        if (!closed) {
            wait(timeoutMillis);
            if (!closed) {
                throw new Exception("MockResponseSender could not be closed");
            }
        }
    }
}

```

### 4.4.3 Недостоверные комментарии

В комментариях может указана информация, которая неточная и не соответствует истине.

### 4.4.4 Обязательные комментарии

Правила, говорящие, что каждая функция должна иметь комментарий `Javadoc` или что каждая переменная должна быть помечена
комментарием - не имеют аргументированных оснований. Такие комментарии загромождают код, добавляют избыточную или
недостоверную информацию.

### 4.4.5 Журнальные комментарии

С появлением систем управления версии, добавление комментария в начало модуля со списком изменения излишне.

### 4.4.6 Шум

Шум в комментариях - утверждение очевидного. Искушение создать "шумовой комментарий" следует заменить решимостью
очистить код.

```java
class AnnualDateRule {
    /** День месяца */
    private int dayOfMonth;

    /** Конструктор по умолчанию */
    protected AnnualDateRule() {
    }

    /**
     * Возвращает день месяца
     *
     * @return день месяца
     */
    public int getDayOfMonth() {
        return dayOfMonth;
    }
}

```

### 4.4.7 Опасный шум

Если "шумовой комментарий" строго не меняется с изменением кода - он опасен.

### 4.4.8 Не используйте комментарии там, где можно использовать функцию или переменную

Плохо:

```java
class Main {
    void method() {
        // Зависит ли модуль из глобального списка <mod> от подсистемы.
        // Частью которой является наш код?
        if (smodule.getDependSubsystems().contains(subSysMod.getSubSystem())) {
        }
    }
}

```

Лучше:

```java
class Main {
    void method() {
        List<String> moduleDependees = smodule.getDependSubsystems();
        String ourSubSystem = subSysMod.getSubSystem();
        if (moduleDependees.contains(ourSubSystem)) {
        }
    }
}

```

### 4.4.9 Позиционные маркеры

Пример:

`// Действия //////////////`

Такие заголовки привлекают внимание только, если они встречаются не слишком часто. Используйте, только если приносят
ощутимую пользу. При злоупотреблении они воспринимаются как фоновый шум.

### 4.4.10 Комментарии за закрывающей фигурной скобкой

Если функция имеет многоуровневые вложенности, то такие комментарии позволяют понять, чему принадлежит закрывающаяся
скобка.

```java
class Main {
    public static void main(String[] args) {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        String line;
        int lineCount = 0;
        int charCount = 0;
        int wordCount = 0;
        try {
            while ((line = in.readLine()) != null) {
                lineCount++;
                charCount += line.length();
                String words[] = line.split("\\W");
                wordCount += words.length;
            } // while
            System.out.println("wordCount = " + wordCount);
            System.out.println("lineCount = " + lineCount);
            System.out.println("charCount = " + charCount);
        } // try
        catch (IOException e) {
            System.err.println("Error:" + e.getMessage());
        } // catch
    } // main
}

```

Следует разделить такие функции на несколько и в подобных комментариях не будет нужды.

### 4.4.11 Ссылки на авторов

`/* Добавлено Риком*/`

С появлением систем контроля, в которой более подробно указано, кто работал с кодом, нет причин указывать такие
комментарии. Со временем с кодом работают много авторов, а тот код который писал автор - больше нет и комментарий
остается не актуальные.

### 4.4.12 Закомментированный код

Не оставляйте закомментированный код, с появлением современных средств контроля версий его можно восстановить. Имейте
храбрость удалить закомментированный код, если его увидели.

### 4.4.13 Комментарии HTML

HTML в комментариях захламляет файл исходного кода. Если комментарии должны извлекаться внешними инструментами, например
Javadoc, для отображения в веб-странице, то за украшение комментариев соответствующим кодом HTML должен отвечать этот
инструмент, а не программист.

### 4.4.14 Нелокальная информация

Комментарий должен описывать код, который находится поблизости, а не описывать информацию системного уровня.

### 4.4.15 Слишком много информации

Не включайте в комментарии интересные исторические дискуссии или описания подробностей, достаточно указать ссылку на
статью/стандарт/stackoverflow.

### 4.4.16 Неочевидные комментарии

Связь между комментарием и кодом, который он описывает, должна быть очевидной. Цель комментария - объяснить код, который
не объяснит сам себя. Плохо, когда сам комментарий нуждается в объяснении.

### 4.4.17 Заголовки функций

Короткие функции не нуждаются в долгих описаниях. Хорошо выбранное имя компактной функции, лучше заголовка.

### 4.4.18 Заголовки Javadoc во внутреннем коде

Применяйте комментарии Javadoc только для API общего пользования. Генерирование Javadoc для внутренних классов и функций
не приносит реальной пользы, а формализм только отвлекает.

# 5 Форматирование

## 5.1 Цель форматирования

### 5.1.1 Вертикальное форматирование

Серьезная система можно построить из файлов с длиной около 200 строк, с верхним пределом 500 строк. Маленькие файлы
обычно более понятны, чем большие.

### 5.1.2 Газетная метафора

Исходный файл должен выглядеть как газетная статья:

* Имя файл должно быть простым, но содержательным. Его должно быть достаточно, чтобы читатель понял - открыл то или нет
* Начальные блоки описывают высокоуровневые концепции и алгоритмы
* Степень детализации увеличивается при перемещении к концу файла, а в самом конце функции и подробности низшего уровня

Газета состоит из множества коротких статей. Бывают чуть длиннее и немногие занимают всю газетную страницу.

### 5.1.3 Вертикальное разделение концепций

Каждая строка представляет выражение или условие, а каждая группа строк представляет законченную мысль. Эти мысли
следует отделять друг от друга пустыми строками.

### 5.1.4 Вертикальное сжатие

Строки кода, между которыми существует тесная связь, должны быть сжаты по вертикали.

### 5.1.5 Вертикальное расстояние

Концепции, тесно связанные друг с другом, должны находиться поблизости друг от друга по вертикали. Их вертикальное
разделение должно показывать, насколько они важны для понимания друг друга.

**Объявление переменных**

* Переменные следует объявлять как можно ближе к месту использования
* В очень коротких функциях, локальные переменные должны перечисляться в начале функции
* Управляющие переменные циклов обычно объявляются внутри конструкции цикла
* Реже переменная может объявляться в начале блока или непосредственно перед циклом в длинной функции

**Переменные экземпляров** - должны объявляться в начале класса(Java) или в одном хорошо известном месте.

**Зависимые функции.** Если одна функция вызывает другую, то эти функции должны располагаться вблизи друг от друга, а
вызывающая функция должна находиться над вызываемой.

**Концептуальное родство.**  Некоторые фрагменты кода требуют, чтобы их разместили вблизи от других фрагментов. Чем
сильнее родство, тем меньше должно быть вертикальное расстояние между ними. Например, группа функций выполняет
аналогичные операции, при этом могу и не вызываться друг из друга.

### 5.1.6 Вертикальное упорядочение

Взаимосвязанные функции должны размещаться в нисходящем порядке. Вызываемая функция должна располагаться ниже вызывающей
функции.

## 5.2 Горизонтальное форматирование

Рекомендуемая верхняя граница строки - 120 символов.

### 5.2.1 Горизонтальное разделение и сжатие

Горизонтальные пропуски используют для группировки взаимосвязанных элементов и разделения разнородных элементов.

```java
class Main {
    void measureLine(String line) {
        lineCount++;
        int lineSize = line.length();
        totalChars += lineSize;
        lineWidthHistogram.addLine(lineSize, lineCount);
        recordWidestLine(lineSize);
    }
}

```

* Знаки присваивания окружены пробелами, обеспечивающими их визуальное выделение и что они состоят из левого и правого
  элемента
* Имена функции не отделяются от открывающих скобок, поскольку оно тесно связано с его именем
* Аргументы в скобках разделены пробелами, чтобы выделить запятые и подчеркнуть, что они не зависят друг от друга

Пробелы для визуального обозначения приоритета операторов:
`(-b + Math.sqrt(determinant)) / (2*a)`

* Между множителями нет пробелов - высокий приоритет
* Слагаемые разделены пробелами - более низкий приоритет

### 5.2.2 Горизонтальное выравнивание

Не следует заморачиваться и выравнивать по горизонтали некоторые структуры кода для визуального выделения. Например,
объявление полей в классе(модификатор доступа, тип и имя пишутся в отдельных "колонках"). Лучше объявление и присвоение
сделать невыровненным, это поможет выявить дефект - слишком большая длина списка переменных(возможно класс требуется
разделить).

### 5.2.3 Отступы

* Команды уровня файла(например, объявление класса) отступов не имеют
* Методы в классах сдвигаются на одни уровень в право от уровня класса
* Реализация этих методов сдвигаются на одни уровень вправо от объявления метода
* Реализация блоков сдвигаются на одни уровень вправо от своих внешних блоков

**Нарушение отступов.** В коротких командах `if`, циклах `while` или коротких функциях есть соблазн свернуть блоки в
одну
строку.

### 5.2.4 Вырожденные области видимости

Если тело цикла `while` или `for` не содержит команд - они являются вырожденными. Лучше избегать таких структур. Если
необходимо их использовать, то нужно следить чтобы они имели также правильные отступы. Точку с запятой лучше разметить
на следующей строке, что бы её сделать хорошо заметной.

### 5.2.5 Правила форматирования в группах

При работе программиста в группе, необходимо следовать единым правилам форматирования, которые утвердила группа. Даже
если у программиста есть свои личные предпочтения.

# 6 Объекты и структуры данных

## 6.1 Абстракция данных

Конкретная реализация(открытая):

```java
public class Point {
    public double x;
    public double y;
}

```

Абстрактная реализация:

```java
public interface Point {
    double getX();

    double getY();

    void setCartesian(double x, double y);

    double getR();

    double getTheta();

    void setPolar(double r, double theta);
}

```

В абстрактной реализации пользователь не знает, какие координаты использованы в реализации - прямоугольные, полярные или
другие. Интерфейс представляет большее, чем структура данных - методы устанавливают политику доступа к данным.

В конкретной реализации пользователь вынужден работать только с прямоугольными координатами. И такое решение раскрывает
реализацию, даже если бы переменные были объявлены приватными и были использованы одиночные методы чтения/записи.

Скрытие реализации не сводится к созданию прослойки функций между переменными. Скрытие реализации направлено на
формирование абстракций. Класс не просто ограничивает данных к переменным через методы чтения/записи. Вместо этого он
предоставляет абстрактные интерфейсы, посредством которых пользователь оперирует с сущностью данных, при этом может не
знать как они реализованы.

Использование интерфейсов тоже не гарантирует абстракцию. В примере ниже, с помощью первого интерфейса для получения
информации о запасе топлива использоваться конкретные физические показатели, а во втором абстрактные проценты.

```java
public interface Vehicle {
    double getFuelTankCapacityInGallons();

    double getGallonsOfGasoline();
}

```

```java
public interface Vehicle {
    double getPercentFuelRemaining();
}

```

Для создания абстрактной реализации не достаточно просто использовать интерфейсы и/или методы чтения/записи, а
необходимо серьезно поразмыслить на абстрактном уровне.

## 6.2 Антисимметрия данных/объектов

Объекты отличаются от структур данных. Объекты скрывают свои данные за абстракциями и предоставляют функции, работающие
с этими данными. Структуры данных раскрывают свои данные и не имеют осмысленных функций.

Процедурный пример, с использованием структур данных, которые не имеют поведения:

```java
public class Square {
    public Point topLeft;
    public double side;
}

public class Rectangle {
    public Point topLeft;
    public double height;
    public double width;
}

public class Circle {
    public Point topLeft;
    public double radius;
}

public class Geometry {
    public final double PI = 3.141592653589793;

    public double area(Object shape) throws NoSuchShapeException {
        if (shape instanceof Square) {
            Square s = (Square) shape;
            return s.side * s.side;
        } else if (shape instanceof Rectangle) {
            Rectangle r = (Rectangle) shape;
            return r.height * r.width;
        } else if (shape instanceof Circle) {
            Circle c = (Circle) shape;
            return PI * c.radius * c.radius;
        }
        throw new NoSuchShapeException();
    }
}

```

Если включить в класс `Geometry` функцию, например `perimeter()`. То классы фигур останутся неизменными и
классы зависимые от них тоже останутся неизменными. Но при добавлении нового класса фигуры, нужно изменять все функции
класса `Geometry`.

Объектно-ориентированное решение с классами объектов реализующий интерфейс:

```java
public class Square implements Shape {
    public Point topLeft;
    public double side;

    public double area() {
        return topLeft * side;
    }
}

public class Rectangle implements Shape {
    public Point topLeft;
    public double height;
    public double width;

    public double area() {
        return height * width;
    }
}

public class Circle implements Shape {
    public Point topLeft;
    public double radius;
    public final double PI = 3.141592653589793;

    public double area() {
        return PI * c.radius * c.radius;
    }
}

```

Класс `Geometry` в данном случае лишний. Добавление новой фигуры не затрагивает ни одну из существующих функций, но при
добавлении новой функции приходится изменять все фигуры(здесь возможно обходные пути).

**Процедурный код (код, использующий структуры данных) позволяет легко добавлять новые функции без изменения
существующих
структур данных. Объектно-ориентированный код, напротив, упрощает добавление новых классов без изменения существующих
функций.**

Обратное утверждение:

**Процедурный код усложняет добавление новых структур данных, потому что оно требует изменения всех функций.
Объектно-ориентированный код усложняет добавление новых функций, потому что для этого должны измениться все классы.**

Представление о том, что все данные должны представлены в виде объектов - миф. Иногда предпочтительны простые структуры
данных и процедуры, работающие с ними.

## 6.3 Закон Деметры

Объект(модуль) не должен знать внутреннее устройство тех объектов, с которыми он работает.
Метод f класса C должен ограничиваться вызовом следующих объектов:

* C
* объекты, созданные в f
* объекты, переданные f в качестве аргумента
* объекты, хранящиеся в переменной экземпляра C

### 6.3.1 Крушение поезда

`final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath();`

Подобные конструкции называют "крушение поезда". Лучше такие цепочки разделить:

```java
class Main {
    void method() {
        Options opts = ctxt.getOptions();
        File scratchDir = opts.getScratchDir();
        final String outputDir = scratchDir.getAbsolutePath();
    }
}

```

Нарушает этот код закон Деметры или нет, все зависит от того, чем являются `ctxt`, `opts`, `scratchDir` - объектами или
структурами данных. Если объекты, то их внутренняя реализация должны скрываться и необходимая информация об их
строении - нарушение закона Деметры. Но если они структуры данных, не обладающие поведением, то они раскрывают свою
структуру и закон Деметры на них не распространяется.

Так как многие стандарты требуют наличие методов доступа и записи, даже на простые структуры данных, чтобы поля были
закрытые. То не всегда сразу понятно, что перед нами структура данных или объект. Если бы код имел следующий вид,
вопросов не возникло:
`final String outputDir = ctxt.options.scratchDir.absolutePath;`

### 6.3.2 Гибриды

Гибридные структуры - наполовину объект, наполовину структура данных. Они содержат как функции для выполнения важных
операций, так и открытые переменные или открытые методы чтения/записи, которые делают приватные переменные открытыми.
Они объединяют худшее из обеих категорий. Подобные гибриды усложняют как добавление новых функций, так и новых структур
данных.

### 6.3.3 Скрытие структуры

Если `ctxt`, `opts`, `scratchDir`(см. выше) представляют собой объекты. Они скрывают свою внутреннюю структуру и из
внешнего метода нельзя перемещаться внутри структуру этих объектов.

В этом случае нужно посмотреть, где используется внутренние данные используемого объекта(`ctxt`) во внешнем методе.

```java
class Main {
    void method() {
        String outFile = outputDir + "/" + className.replace('.', '/') + ".class";
        FileOutputStream fout = new FileOutputStream(outFile);
        BufferedOutputStream bos = new BufferedOutputStream(fout);
    }
}

```

И необходимо передать данное действие классу объекта `ctxt`:

`BufferedOutputStream bos = ctxt.createScratchFileStream(classFileName);`

### 6.3.4 Объекты передачи данных

Основное представление структуры данных является класс с открытыми переменными и без функции. Их ещё называют объектами
передачи данных или **DTO**(Data Transfer Object).

Наиболее распространенной формой **DTO** стала форма bean-компонентов. Она состоит из приватных переменных, операции с
которыми осуществляются при помощи методов чтения/записи. Это является псевдоинкапсуляцией и не имеет серьезных
преимуществ.

### 6.3.5 Активные записи

Активные записи(Active Records) одни из видов **DTO**. Они похожи на bean-компоненты, но обычно в них присутствуют
навигационные методы `save` или `find`.

Нежелательно включать в них методы, реализующие бизнес-логику, так как они превращаются в гибридную структуру.

# 7 Обработка ошибок

## 7.1 Используйте исключения вместо кодов ошибок

Раньше языки программирования не поддерживали механизм обработки исключения. Программа либо устанавливала флаг ошибки,
либо возвращала код, который проверялся вызывающей стороной. Это сильно загромождает код.

Флаг и возвращаемый код:

```java
class DeviceController {

    void sendShutDown() {
        DeviceHandle handle = getHandle(DEV1);
        // Проверить состояние устройства
        if (handle != DeviceHandle.INVALIDE) {
            // Сохранить состояние устройства в поле записи
            retrieveDeviceRecord(handle);
            // Если устройство не приостановлено, отключить его
            if (record.getStatus() != DEVICE_SUSPENDED) {
                pauseDevice(handle);
                clearDeviceWorkQueue(handle);
                closeDevice(handle);
            } else {
                logger.log("Device suspended. Unable to shut down");
            }
        } else {
            logger.log("Invalid handle for: " + DEV1.toString());
        }
    }
}

```

С выдачей исключений и их обработка:

```java
class DeviceController {

    void sendShutDown() {
        try {
            tryToShutDown();
        } catch (DeviceShutDownError e) {
            logger.log(e);
        }
    }

    private tryToShutDown() throws DeviceShutDownError {
        DeviceHandle handle = getHandle(DEV1);
        DeviceRecord record = retrieveDeviceRecord(handle);

        pauseDevice(handle);
        clearDeviceWorkQueue(handle);
        closeDevice(handle);
    }

    private DeviceHandle getHandle(DeviceID id) throws DeviceShutDownError {
        // ...
        throw new DeviceShutDownError("Invalid handle for: " + id.toString());
        // ...
    }
}

```

Это упрощает код и два аспекта - алгоритм отключения устройства и обработка ошибок, теперь изолированы друг от друга.

## 7.2 Начните с написания команды try-catch-finally

Исключения определяют область видимости. Размещая код в блоке `try`, программист утверждает, что выполнение программы
может прерваться в любом месте и продолжиться в блоке `catch`.

Поскольку блок `catch` должен оставить программу в целостном состоянии, что бы и произошло в `try`. Рекомендуется
начинать написание кода, который может инициировать исключение, начинать с `try-catch-finally`.

Например, при методологии **TDD**, можно вначале написать тест, проверяющий инициализируемое исключение и реализовать
это в разрабатываемом методе. Затем добавлять логику в метод, и писать тесты для реализуемой логики.

```java
class Main {
    @Test(expected = StorageException.class)
    public void retrieveSectionShouldThrowOnInvalidFileName() {
        sectionStore.retrieveSection("invalid - file");
    }

    public List<RecordedGrip> retrieveSection(String sectionName) {
        try {
            FileInputStream stream = new FileInputStream(sectionName);
            // Реализовать здесь логику
            stream.close();
        } catch (FileNotFoundException e) {
            throw new StorageException("retrieval error", e);
        }
        return new ArrayList<>();
    }
}
```

## 7.3 Используйте непроверяемые исключения

Проверяемые исключения не являются необходимым для создания надежных программ.
Проверяемые исключения могут нарушить принцип открытости/закрытости. Если инициировать проверяемое исключение из метода
своего кода, а `catch` находится тремя уровнями выше, то исключение должно быть объявлено в сигнатурах всех методов
между инициацией и `catch`. Следовательно, изменения на низком уровне, приводят к изменениям сигнатур на более высоких
уровнях. Это нарушает инкапсуляцию - все функции должны располагать подробной информацией об низкоуровневом исключении.

## 7.4 Передавайте контекст с исключениями

Каждое исключение, должно содержать сообщение с информацией о сбойной операции и типе сбоя, необходимая для определения
источника и местонахождения ошибки. Только по трассировке стека невозможно узнать цель выполнения операции.

## 7.5 Определяйте классы исключений в контексте потребностей вызывающей стороны

Есть множество способов классификации ошибок: по источнику, по типу. Но при создании классов исключений в первую очередь
следует подумать как они будут обрабатываться.

Неудачная классификация исключений:

```java
class Main {
    void method() {
        ACMEPort port = new ACMEPort(12);

        try {
            port.open();
        } catch (DeviceResponseExeption e) {
            reportPortError(e);
            logger.log("Device response exception", e);
        } catch (ATM1212UnlockedException e) {
            reportPortError(e);
            logger.log("Unlock exception", e);
        } catch (GMXError e) {
            reportPortError(e);
            logger.log("Device response exception", e);
        } finally {
            // ...
        }
    }
}

```

* Конструкция содержит множество повторений,
* В большинстве выполняется стандартные действия, не зависящие от реальной причины

Поскольку выполняемая работа при обработке исключения остается примерно постоянной, можно использовать "обертку":

```java
class Main {
    void method() {
        LocalPort port = new LocalPort(12);

        try {
            port.open();
        } catch (PortDeviceFailure e) {
            reportPortError(e);
            logger.log(e.getMessage(), e);
        } finally {
            // ...
        }
    }
}

class LocalPort {
    private ACMEPort innerPort;

    public LocalPort(int portNumber) {
        innerPort = new ACMEPort(portNumber);
    }

    public void open() {
        try {
            innerPort.open();
        } catch (DeviceResponseExeption e) {
            throw new PortDeviceFailure(e);
        } catch (ATM1212UnlockedException e) {
            throw new PortDeviceFailure(e);
        } catch (GMXError e) {
            throw new PortDeviceFailure(e);
        }
    }
}

```

`LocalPort` представляет обертку, которая перехватывает и преобразует исключения:

* С созданием обертки для стороннего вызова исключения, сокращается зависимость в коде и можно переключиться на другую
  библиотеку без серьезных проблем
* Упрощает имитацию сторонних вызовов в ходе тестирования
* Не ограничиваетесь архитектурными решениями внешнего API, можно определить тот API, который удобен(в примере был
  определен один тип исключения)

_Я бы добавил в реализацию обработки исключения в обертке сообщения об ошибке._

Часто достаточно одного класса исключения. С помощью сообщения в исключении можно различить разные виды ошибок.
Используйте разные классы исключений в том случае, если необходимо перехватить одни исключения, разрешая прохождение
других типов.

## 7.6 Определите нормальный путь выполнения

В некоторых ситуациях невозможно изолировать обработку ошибок в другие классы/методы, когда ошибки влияют на
бизнес-логику.

```java
class Main {
    void method() {
        try {
            MealExpenses expenses = expenseReportDao.getMeals(employee.getId());
            mTotal += expenses.getTotal();
        } catch (MealExpensesNotFound e) {
            mTotal += getMealPerDieam();
        }
    }
}

```

В данном случае можно применить паттерн **Особый случай**(Special case). Класс `ExpenseReportDao`, при отсутсвии
подходящего объекта должен возвращать объект `MealExpense` по-умолчанию.

```java
class PerDiemMealExpenses implements MealExpenses {
    public int getTotal() {
        // Вернуть стандартные ежедневные затраты на питание
    }
}

```

## 7.7 Не возвращайте null

Проверка на `null` загромождает код. Если в определенных случаях метод должен вернуть `null`, можно рассмотреть варианты
с возвратом исключения, объекта "особого случая", пустого листа или специальные объекты(`java.util.Optional`). Так для
клиента вашего метода нет необходимости каждый раз проверять на `null`.

## 7.8 Не передавайте null

Возвращать `null` из методов плохо, но передавать `null` ещё хуже.
Если из-за передачи в качестве аргументов значение `null` может возникнуть ошибка, следует запретить передачу, добавив
обработку:

```java
class metricsCalculator {
    public double xProjection(Point p1, Point p2) {
        if (p1 = null || p2 == null) {
            throw new IllegalArgumentException("Invalid argument fo MetricsCalculatro.xProjection");
        }
        return (p2.x - p1.x) * 1.5;
    }
}

```

# 8 Границы

## 8.1 Использование стороннего кода

