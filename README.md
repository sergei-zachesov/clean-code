# Краткое содержание "Чистый код: создание, анализ и рефакторинг", Роберт Мартин

## Описание

Это мой конспект
книги ["Чистый код: создание, анализ и рефакторинг", Роберт Мартин](https://www.piter.com/collection/all/product/chistyy-kod-sozdanie-analiz-i-refaktoring-biblioteka-programmista-45ccca) (
сайт российского издательства).

Если Вы автор и считаете, что данный конспект нарушает авторские права - прошу сообщить, я сделаю этот репозиторий
приватным.

Нашли опечатку/неточность? Пишите - разберемся.

[Связаться со мной](https://t.me/szachesov)

# 1. Содержание

- [1. Содержание](#1-содержание)
- [2. Содержательные имена](#2-содержательные-имена)
    - [2.1 Имена должны передавать намерения программиста](#21-имена-должны-передавать-намерения-программиста)
    - [2.2 Избегайте дезинформации](#22-избегайте-дезинформации)
    - [2.3 Используйте осмысленные различия](#23-используйте-осмысленные-различия)
    - [2.4 Используйте удобопроизносимые имена](#24-используйте-удобопроизносимые-имена)
    - [2.5 Выбирайте имена, удобные для поиска](#25-выбирайте-имена-удобные-для-поиска)
    - [2.6 Избегайте схем кодирования имен](#26-избегайте-схем-кодирования-имен)
        - [2.6.1 Венгерская запись](#261-венгерская-запись)
        - [2.6.2 Префиксы членов классов](#262-префиксы-членов-классов)
        - [2.6.3 Интерфейсы и реализации](#263-интерфейсы-и-реализации)
    - [2.7 Избегайте мысленных преобразований](#27-избегайте-мысленных-преобразований)
    - [2.8 Имена классов](#28-имена-классов)
    - [2.9 Имена методов](#29-имена-методов)
    - [2.10 Избегайте остроумия](#210-избегайте-остроумия)
    - [2.11 Выберите одно слово для каждой концепции](#211-выберите-одно-слово-для-каждой-концепции)
    - [2.12 Воздержитесь от каламбуров](#212-воздержитесь-от-каламбуров)
    - [2.13 Используйте имена из пространства решения](#213-используйте-имена-из-пространства-решения)
    - [2.14 Используйте имена из пространства задач](#214-используйте-имена-из-пространства-задач)
    - [2.15 Добавьте содержательный контекст](#215-добавьте-содержательный-контекст)
    - [2.16 Не добавляйте избыточный контекст](#216-не-добавляйте-избыточный-контекст)
- [3. Функции](#3-функции)
    - [3.1 Компактность!](#31-компактность)
        - [3.1.1 Блоки и отступы](#311-блоки-и-отступы)
    - [3.2 Правило одной функции](#32-правило-одной-функции)
        - [3.2.1 Секции в функциях](#321-секции-в-функциях)
    - [3.3 Один уровень абстракции на функцию](#33-один-уровень-абстракции-на-функцию)
        - [3.3.1 Чтение кода сверху вниз: правило понижения](#331-чтение-кода-сверху-вниз-правило-понижения)
    - [3.4 Команды switch](#34-команды-switch)
    - [3.5 Используйте содержательные имена](#35-используйте-содержательные-имена)
    - [3.6 Аргументы функций](#36-аргументы-функций)
        - [3.6.1 Стандартные унарные формы](#361-стандартные-унарные-формы)
        - [3.6.2 Аргументы-флаги](#362-аргументы-флаги)
        - [3.6.3 Бинарные функции](#363-бинарные-функции)
        - [3.6.4 Тернарные функции](#364-тернарные-функции)
        - [3.6.5 Объекты как аргументы](#365-объекты-как-аргументы)
        - [3.6.6 Списки аргументов](#366-списки-аргументов)
        - [3.6.7 Глаголы и ключевые слова](#367-глаголы-и-ключевые-слова)
    - [3.7 Избавьтесь от побочных эффектов](#37-избавьтесь-от-побочных-эффектов)
        - [3.7.1 Выходные аргументы](#371-выходные-аргументы)

# 2. Содержательные имена

## 2.1 Имена должны передавать намерения программиста

Следите за именами и изменяйте их, если найдете более удачные варианты.

Имя переменной, функции или класса должно сообщить, почему существует эта сущность, что она делает и как используется.
Если имя требует комментарии - оно не передает намерения программиста.

Не выразительные имена:

```java
public class Minesweeper {
    public List<int[]> getThem() {
        List<int[]> list1 = new ArrayList<>();
        for (int[] x : theList) {
            if (x[0] == 4) {
                list1.add(x);
            }
        }
        return list1;
    }
}

```

Добавление имен, на примере игры "Сапер":

```java
public class Minesweeper {
    public List<int[]> getFlaggedCells() {
        List<int[]> flaggedCells = new ArrayList<>();
        for (int[] cell : gameBoard) {
            if (x[STATUS_VALUE] == FLAGGED) {
                flaggedCells.add(cell);
            }
        }
        return flaggedCells;
    }
}

```

Добавление класса, для описания ячеек:

```java
public class Minesweeper {
    public List<Cell> getFlaggedCells() {
        List<Cell> flaggedCells = new ArrayList<>();
        for (Cell cell : gameBoard) {
            if (cell.isFlagged()) {
                flaggedCells.add(cell);
            }
        }
        return flaggedCells;
    }
}

```

## 2.2 Избегайте дезинформации

Нужно избегать ложных ассоциаций, затемняющий смысл кода. Не используйте слова со скрытыми значениями, отличными от
предполагаемого.

Обозначение группы ученых. Плохо: `accountList`, если только действительно не используется `List`.
Лучше: `accountGroup`, `bunchOfAccounts`, `accounts`.

Остерегайтесь малозаметных различий в именах: `XYZControllerForEfficientHandlingOfStrings`
и `XYZControllerForEfficientStorageOfStrings`.

Избегайте использование строчно `L` и прописной `O` в названиях переменной, поскольку они почти не отличаются от `1`
и `0` соответственно.

## 2.3 Используйте осмысленные различия

"Числовые ряды" (a1, a2 ... aN) такие имена не дезинформируют, но не несут никакой информации.

Не информативные слова в названиях:

* слова для создания бессодержательных различий: классы `ProductInfo` или `ProductData`
* слово `variable` для имен переменных, `table` в именах таблиц и тп
* название типа `nameString`, для переменной которая будет навряд ле будет не строковым значением
* дополнительное слово `Object` в названии класса

## 2.4 Используйте удобопроизносимые имена

Например, не надо называть переменные не общеизвестной аббревиатурой или сокращать: `genymdhms` (дата генерирования,
год, месяц, день, час, минуты и секунды) или `modymdhms` (дата модификации, год, месяц, день, час, минуты и секунды),
лучше `generationTimestamp` и `modificationTimestamp` соответственно.

## 2.5 Выбирайте имена, удобные для поиска

Трудно искать в большом объеме текса однобуквенные переменные и числовые константы.

Буква `e` - самая распространенная буква английского алфавита, не стоит присваивать её имени переменной. Трудно будет
найти в тексте.

Однобуквенные переменные могут использоваться ТОЛЬКО для локальных переменных. Длина имени должна соответствовать
размеру его области видимости.

## 2.6 Избегайте схем кодирования имен

У программистов и так хватает хлопот с кодированием.

## 2.6.1 Венгерская запись

Было распространено в старых языках программирования, когда были ограничения на длину имени или невозможность объявить
тип переменной. Современные языки существует развитая система типов, а компиляторы запоминают их и обеспечивают их
соблюдение.

## 2.6.2 Префиксы членов классов

Классы и функции должны быть достаточно компактными, чтобы могли обходиться без префиксов.

## 2.6.3 Интерфейсы и реализации

Если есть выбор добавления кодирования в интерфейсы или классы, чтобы имена не дублировались,
например, `interface IShapeFactory` или `class ShapeFactoryImpl`. Лучше выбрать класс, чтобы не сообщать пользователю,
что имеют дело с интерфейсов, в том числе из-за полиморфного использования типов переменных.

## 2.7 Избегайте мысленных преобразований

Не заставляйте читателя мысленно преобразовывать ваши имена в другие. Как правило, такие проблемы происходят с именами
переменной однобуквенными или сокращенными, особенно если используется не в ограниченной области видимости.

## 2.8 Имена классов

* Должны быть существительные и их комбинации: `WikiPage`, `AddressParser`
* Стараться не использовать такие слова в именах `Manager`, `Processor`, `Data` или `Info`
* Имена не должны быть глаголом

## 2.9 Имена методов

* Должны быть глаголы или глагольные словосочетания: `postPayment`, `deletePage`, `save` и т.д.
* Методы чтения/записи и предикаты образуются из значений и префиксов: `get`, `set`, `is` согласно `javabean`
* При перезагрузке конструкторов предпочесть статистические методы-фабрики с именами, описывающие
  аргументы: `Complex fulcrumPoint = Complex.fromRealNumber(23.0)`, лучше `Complex fulcrumPoint = new Complex(23.0)`

## 2.10 Избегайте остроумия

Отдавайте предпочтение ясности перед развлекательной ценностью, а также формы просторечия или сленга.

## 2.11 Выберите одно слово для каждой концепции

Выберите одно слово для представления одной абстрактной концепции и придерживайтесь его. Существование в разных классах
эквивалентных методов с именами `fetch`, `retrieve` и `get` создаст путаницу.
Использование терминов `controller`, `manager` и `driver` в одной кодовой базе может вызвать путаницу.

## 2.12 Воздержитесь от каламбуров

Старайтесь не использовать одно слово в двух смыслах. Обозначение двух разных идей одним терминов - каламбур.
Например, существуют классы с именем метода `add`, который создает объект-значение с помощью сложение. То не следует в
другой класс называть метод `add` который добавляет объект в коллекцию, поскольку он имеет другую семантику, лучше
назвать его `insert` или `append`.

## 2.13 Используйте имена из пространства решения

Код читают программиста, поэтому можно использовать термины из области информатики, названия алгоритмов и паттернов,
математические термины и тп. Например, `JobQueue` - "очередь задач". Не ограничивайте именами только из пространства
конкретной задачи.

## 2.14 Используйте имена из пространства задач

Если нет подходящего имени из пространства решения, можно использовать имя из пространства конкретной задачи.

## 2.15 Добавьте содержательный контекст

Мало имен, которые содержательны сами по себе. Все остальные следует помещать в контекст для читателя кода, заключая их
в классы, функции и пространства имен. В крайнем случае контекст имени можно уточнить при помощи
префикса: `firstName`, `lastName`.

Имя функции определяет только часть контекста, остальное определяет сам алгоритм:

```java
public class Main {
    private void printGuessStatistics(char candidate, int count) {
        String number;
        String verb;
        String pluralModifier;

        if (count == 0) {
            number = "no";
            verb = "are";
            pluralModifier = "s";
        } else if (count == 1) {
            number = "1";
            verb = "is";
            pluralModifier = "";
        } else {
            number = Integer.toString(count);
            verb = "are";
            pluralModifier = "s";
        }

        String guessMessage =
                String.format("There %s %s %s%s", verb, number, candidate, pluralModifier);
        print(guessMessage);
    }
}

```

Функция выше длинная, переменные используются на все её протяжении.

Чтобы сократить функцию, можно вынести логику функции в класс, предоставляя очевидный контекст для переменных, а также
улучшить четкость алгоритма за счет деления на меньшие функции:

```java
public class GuessStatisticsMessage {
    private String number;
    private String verb;
    private String pluralModifier;

    public String make(char candidate, int count) {
        createPluralDependentMessageParts(count);
        return String.format("There %s %s %s%s", verb, number, candidate, pluralModifier);
    }

    private void createPluralDependentMessageParts(int count) {
        if (count == 0) {
            thereAreNoLetters();
        } else if (count == 1) {
            thereIsOneLetter();
        } else {
            thereAreManyLetters(count);
        }
    }

    private void thereAreNoLetters(int count) {
        number = Integer.toString(count);
        verb = "are";
        pluralModifier = "s";
    }

    private void thereIsOneLetter() {
        number = "1";
        verb = "is";
        pluralModifier = "";
    }

    private void thereAreNoLetters() {
        number = "no";
        verb = "are";
        pluralModifier = "s";
    }
}

```

## 2.16 Не добавляйте избыточный контекст

Если название приложение, например "Gas Station Deluxe", то не надо добавлять к имени каждого класса `GSD`.

Короткие имена обычно лучше длинных, если только их смысл понятен читателю кода. Не включайте в имя больше контекст, чем
необходимо.

Имена `accountAddress` и `customerAddress` хорошо подходят для экземпляров класса `Address`, но не для имен классов.
Если потребуется подчеркнуть, например, различия между MAC-адресами, адресами портов и веб-адресами, можно классы
назвать именами `PostalAddress`, `Mac`, `Url`.

# 3. Функции

# 3.1 Компактность!

Желательно, функция не должна превышать 20 строк. В идеале 2-4 строки.

# 3.1.1 Блоки и отступы

* В блоках `if`, `else`, `while` и т.д. должны состоять из одной строчки, в которой обычно вызывается функция. Вмещающая
  функция становится компактной и документируется код
* Функции не должны содержать вложенных структур (C++)
* Максимальный уровень отступов в функциях - 1-2

# 3.2 Правило одной функции

Функция должна выполнять только одну операцию. Она должна выполнят её хорошо. И ничего другого она делать не должна.

Если функция выполняет только те действия, которые находятся на одном уровне под объявленным именем функции, то эта
функция выполняет одну операцию.

Если команду `if` вынести в отдельную функцию с именем `includeSetupAndTeardownIfTestPages`, то это простая
переформулировка кода без изменения уровня абстракции.

```java
class Main {

    public static String renderPageWithSetupsAndTeardowns(PageData pageData, boolean isSuite) {
        if (isTestPage(pageData)) {
            includeSetupAndTeardownPages(pageData, isSuite);
        }
        return pageData.getHtml();
    }
}

```

Чтобы определить, что функция выполняет только одну операцию, попробуйте извлечь из неё другую функцию, которая являлась
простой переформулировкой реализации.

# 3.2.1 Секции в функциях

Функцию, выполняющую только одну операцию, невозможно осмысленно разделить на секции.

# 3.3 Один уровень абстракции на функцию

Что бы функции выполняли только одну операцию, все команды кода должны быть на одном уровне абстракции.

_Пример уровней абстракции: подключение к бд (низкий), CRUD работа с бд (средний), отправка конкретной формы (высокий)_

# 3.3.1 Чтение кода сверху вниз: правило понижения

Код должен читаться как рассказ - сверху вниз.

Правило понижения - когда каждая функция находится на одном уровне абстракции и можно читать код последовательно,
спускаясь по уровням.

# 3.4 Команды switch

Если требуется применить команду `switch`, можно скрыть её на низкоуровнем классе и не дублировать в коде, в этом
поможет полиморфизм.

```java
class Main {

    public Money calculatePay(Employee e) throws InvalidEmployeeType {
        switch (e.type) {
            case COMMISSIONED:
                return calculateCommissionedPay(e);
            case HOURLY:
                return calculateHourlyPay(e);
            case SALARIED:
                return calculateSalariedPay(e);
            default:
                throw new InvalidEmployeeType(e);
        }
    }
}

```

Недостатки:

1. Функция велика и при добавлении новых типов - разрастется
2. Выполняет более одной операции
3. Нарушает принцип "единой ответственности"
4. Нарушает принцип "открытости/закрытности", код должен изменяться при каждом добавлении новой функции

Решение: перемести команду `switch` в абстрактную фабрику.

```java
public abstract class Employee {
    abstract boolean isPayday();

    abstract Money calculatePay();

    abstract void deliverPay(Money pay);
}

public interface EmployeeFactory {
    Employee makeEmployee(EmployeeRecod r) throws InvalidEmployeeType;
}

public class EmployeeFactoryImpl implements EmployeeFactory {
    Employee makeEmployee(EmployeeRecod r) throws InvalidEmployeeType {
        switch (e.type) {
            case COMMISSIONED:
                return new CommissionedEmployee(r);
            case HOURLY:
                return new HourlyEmployee(r);
            case SALARIED:
                return new SalariedEmploye(r);
            default:
                throw new InvalidEmployeeType(r.type);
        }
    }
}

```

Команда `switch` допустимы, если они встречаются в программе однократно, используются для создания полиморфных объектов
и скрываются за отношениями наследования, чтобы оставаться невидимыми для остальных частей программы.

_В java11 можно воспользоваться более компактной записью `switch`. Решение в `Java. Эффективное программированиме`
насчет `switch` и `enum` более элегантное, по моему мнению._

# 3.5 Используйте содержательные имена

Длинное содержательное имя лучше короткого невразумительного. Выберете схему, которая позволить легко прочитать слова в
имени. Затем составьте из этих слов имя, которое описывает назначение функции.
Не бойтесь расходовать время на выбор имени. Опробуйте несколько разных имен и посмотрите, как читается кода с каждым из
вариантов.
Используйте в именах функций те же словосочетания, глаголы и существительные, которые используются в ваших модулях.

# 3.6 Аргументы функций

В идеале кол-во аргументов функции равно нулю. Функции с тремя аргументами следует избегать. Необходимость большего
кол-во аргументов должна подкреплена очень вескими доводами.

Если аргументов больше двух, задача тестирования всех возможных комбинаций выглядит все более устрашающе.

Обычно предполагается, что функция получает информацию в аргументах, и выдает её в возвращаемом значении. Как правило,
никто не ожидает, что функция будет возвращать информацию в аргументах.

# 3.6.1 Стандартные унарные формы

Случаи вызова функции с одним аргументом:

1. Проверка некоторого условия, связанного с аргументом, например `boolean fileExists("MyFile")`
2. Обработка аргумента, его преобразование и возращение, например `InputStream fileOpen("MyFile")`
3. (Редкий) Событие - программа интерпретирует вызов функции как событие и использует аргумент для изменения состояния
   системы, например `void passwordAttemptFailedNtimes(int attempts)`

Стараться избегать унарных функций, не относящиеся к этим формам, например `void transform(StringBuffer in)`
преобразовывает входной аргумент, лучше добавить возражающее значение `StringBuffer transform(StringBuffer out)`.

# 3.6.2 Аргументы-флаги

Старайтесь не использовать аргументы-флаги. Такая функция будет выполнять более одной операции. Лучше разбить функцию на
две.

# 3.6.3 Бинарные функции

Функции с двумя аргументами менее предпочтительно, чем с одним. Стоит, по возможности преобразовать в унарные.

В некоторых случаях они являются логичными, например `Point p = new Point(0, 0)`, в данном случае они являются
упорядоченными компонентами одного значения.

`writeField(outputStream, name)` - аргументы не имеют ни естественной связи, ни естественного порядка. В данном случае
можно сделать метод `writeField` членом класса outStream(???), чтобы использовать запись `outputStream`. Либо
преобразование`outputStream` в поле текущего класса, чтобы переменную не приходилось передавать при вызове. Либо можно
сделать новый класс `FieldWrite` с полем `outputStream` и содержит метод `write`.

# 3.6.4 Тернарные функции

Лучше хорошо подумать, прежде создания данной функции.

Проблемы функций с тремя аргументами:

* Проблемы соблюдения порядка аргументов
* Приостановки чтения и игнорирование кода увеличены

Бывают исключения: `assertEquals(1.0, amount, .001)`

# 3.6.5 Объекты как аргументы

Если функция более 2-3 аргументов, можно попробовать несколько аргументов упаковать в отдельный класс.
Например:

`Circle makeCircle(double x, double y, double radius)` => `Circle makeCircle(Point center, double radius)`

Если переменные передаются как единое целое, то, скорее всего, они образуют концепцию.

# 3.6.6 Списки аргументов

Функции с переменным списком аргументов могут быть унарными, бинарными и тернарными, но использование большое количество
аргументов было бы ошибкой:

* `void monad(Integer... args)`
* `void dyad(String name, Integer... args)`
* `void triad(String name, int count, Integer... args)`

# 3.6.7 Глаголы и ключевые слова

В унарных функциях, само имя и её аргумент должны образовывать естественную пару "глагол/существительное", например
`write(name)` - записать имя, `writeField(name)` - записать в поле имя.
При использовании ключевых слов в имени функции, можно закодировать имена аргументов в имени функции: `assertEquals`
записать в виде `assertExpectedEqualsActual(expected, actual)`.

# 3.7 Избавьтесь от побочных эффектов

Побочные действие функции - обещает делать что-то одно, но делает ещё и другой, скрытое от пользователя. Порой с
неожиданным результатом.
Побочный эффект создает временную привязку, когда побочное действие может выполниться некорректно, из-за неподходящего
времени вызова функции.

# 3.7.1 Выходные аргументы

